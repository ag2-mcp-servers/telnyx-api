# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T10:25:05+00:00



import argparse
import json
import os
from datetime import date
from datetime import datetime as datetime_aliased
from typing import *
from typing import Optional, Union
from uuid import UUID

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBearer
from fastapi import Path, Query, UploadFile
from pydantic import conint

from models import (
    Action1,
    ActionsActionTelephonyCredentialsPostResponse,
    ActionsBulkTelephonyCredentialsDeleteResponse,
    ActionsBulkTelephonyCredentialsPatchResponse,
    ActionsBulkTelephonyCredentialsPostResponse,
    ActionsNetworkPreferencesSimCardsPutRequest,
    ActionsNetworkPreferencesSimCardsPutResponse,
    ActionsRegisterSimCardsPostResponse,
    ActivationStatus,
    AddressCreate,
    AddressesActionsValidatePostResponse,
    AddressesGetResponse,
    AddressesIdDeleteResponse,
    AddressesIdGetResponse,
    AddressesPostResponse,
    AggregationType3,
    AggregationType5,
    AnswerRequest,
    AuthenticationProviderCreate,
    AuthenticationProvidersGetResponse,
    AuthenticationProvidersIdDeleteResponse,
    AuthenticationProvidersIdGetResponse,
    AuthenticationProvidersIdPatchResponse,
    AuthenticationProvidersPostResponse,
    AvailablePhoneNumberBlocksGetResponse,
    AvailablePhoneNumbersGetResponse,
    BalanceGetResponse,
    BillingGroupsGetResponse,
    BillingGroupsIdDeleteResponse,
    BillingGroupsIdGetResponse,
    BillingGroupsIdPatchResponse,
    BillingGroupsPostResponse,
    BridgeRequest,
    BulkCredentialRequest,
    CallAnsweredEvent,
    CallBridgedEvent,
    CallControlApplicationsGetResponse,
    CallControlApplicationsIdDeleteResponse,
    CallControlApplicationsIdGetResponse,
    CallControlApplicationsIdPatchResponse,
    CallControlApplicationsPostResponse,
    CallDtmfReceivedEvent,
    CallEnqueuedEvent,
    CallEventsGetResponse,
    CallForkStartedEvent,
    CallForkStoppedEvent,
    CallGatherEndedEvent,
    CallHangupEvent,
    CallInitiatedEvent,
    CallLeftQueueEvent,
    CallMachineDetectionEndedEvent,
    CallMachineGreetingEndedEvent,
    CallPlaybackEndedEvent,
    CallPlaybackStartedEvent,
    CallRecordingSavedEvent,
    CallReferCompletedEvent,
    CallReferFailedEvent,
    CallReferStartedEvent,
    CallRequest,
    CallsCallControlIdActionsAnswerPostResponse,
    CallsCallControlIdActionsBridgePostResponse,
    CallsCallControlIdActionsEnqueuePostResponse,
    CallsCallControlIdActionsForkStartPostResponse,
    CallsCallControlIdActionsForkStopPostResponse,
    CallsCallControlIdActionsGatherStopPostResponse,
    CallsCallControlIdActionsGatherUsingAudioPostResponse,
    CallsCallControlIdActionsGatherUsingSpeakPostResponse,
    CallsCallControlIdActionsHangupPostResponse,
    CallsCallControlIdActionsLeaveQueuePostResponse,
    CallsCallControlIdActionsPlaybackStartPostResponse,
    CallsCallControlIdActionsPlaybackStopPostResponse,
    CallsCallControlIdActionsRecordPausePostResponse,
    CallsCallControlIdActionsRecordResumePostResponse,
    CallsCallControlIdActionsRecordStartPostResponse,
    CallsCallControlIdActionsRecordStopPostResponse,
    CallsCallControlIdActionsReferPostResponse,
    CallsCallControlIdActionsRejectPostResponse,
    CallsCallControlIdActionsSendDtmfPostResponse,
    CallsCallControlIdActionsSpeakPostResponse,
    CallsCallControlIdActionsTranscriptionStartPostResponse,
    CallsCallControlIdActionsTranscriptionStopPostResponse,
    CallsCallControlIdActionsTransferPostResponse,
    CallsCallControlIdGetResponse,
    CallSpeakEndedEvent,
    CallSpeakStartedEvent,
    CallsPostResponse,
    CdrGetSyncUsageReportResponse,
    CheckContactRequestBody,
    Comment,
    CommentsGetResponse,
    CommentsIdGetResponse,
    CommentsIdReadPatchResponse,
    CommentsPostResponse,
    ConferenceCallRequest,
    ConferenceCreatedEvent,
    ConferenceEndedEvent,
    ConferenceFloorChangedEvent,
    ConferenceHoldRequest,
    ConferenceMuteRequest,
    ConferenceParticipantJoinedEvent,
    ConferenceParticipantLeftEvent,
    ConferenceParticipantPlaybackEndedEvent,
    ConferenceParticipantPlaybackStartedEvent,
    ConferenceParticipantSpeakEndedEvent,
    ConferenceParticipantSpeakStartedEvent,
    ConferencePlaybackEndedEvent,
    ConferencePlaybackStartedEvent,
    ConferencePlayRequest,
    ConferenceRecordingSavedEvent,
    ConferencesConferenceIdParticipantsGetResponse,
    ConferencesGetResponse,
    ConferencesIdActionsDialParticipantPostResponse,
    ConferencesIdActionsHoldPostResponse,
    ConferencesIdActionsJoinPostResponse,
    ConferencesIdActionsLeavePostResponse,
    ConferencesIdActionsMutePostResponse,
    ConferencesIdActionsPlayPostResponse,
    ConferencesIdActionsRecordStartPostResponse,
    ConferencesIdActionsRecordStopPostResponse,
    ConferencesIdActionsSpeakPostResponse,
    ConferencesIdActionsStopPostResponse,
    ConferencesIdActionsUnholdPostResponse,
    ConferencesIdActionsUnmutePostResponse,
    ConferencesIdActionsUpdatePostResponse,
    ConferencesIdGetResponse,
    ConferenceSpeakEndedEvent,
    ConferenceSpeakRequest,
    ConferenceSpeakStartedEvent,
    ConferencesPostResponse,
    ConferenceStopRequest,
    ConferenceUnholdRequest,
    ConferenceUnmuteRequest,
    Connections1,
    ConnectionsGetResponse,
    ConnectionsIdGetResponse,
    CreateCallControlApplicationRequest,
    CreateConferenceRequest,
    CreateCredentialConnectionRequest,
    CreateDocServiceDocumentRequest,
    CreateFaxApplicationRequest,
    CreateFqdnConnectionRequest,
    CreateFqdnRequest,
    CreateIpConnectionRequest,
    CreateIpRequest,
    CreateLongCodeMessageRequest,
    CreateManagedAccountRequest,
    CreateMessageRequest,
    CreateMessagingHostedNumberOrderRequest,
    CreateMessagingProfileRequest,
    CreateNumberBlockOrderRequest,
    CreateNumberOrderDocumentRequest,
    CreateNumberOrderRequest,
    CreateNumberPoolMessageRequest,
    CreateNumberReservationRequest,
    CreateOutboundVoiceProfileRequest,
    CreatePortingOrder,
    CreatePortingOrderComment,
    CreateRoomClientTokenRequest,
    CreateRoomRequest,
    CreateShortCodeMessageRequest,
    CreateTexmlApplicationRequest,
    CreateVerificationRequestCall,
    CreateVerificationRequestFlashcall,
    CreateVerificationRequestPSD2,
    CreateVerificationRequestSMS,
    CreateVerificationRequestWhatsapp,
    CreateVerificationResponse,
    CreateWhatsAppMessageRequest,
    CredentialConnectionsGetResponse,
    CredentialConnectionsIdDeleteResponse,
    CredentialConnectionsIdGetResponse,
    CredentialConnectionsIdPatchResponse,
    CredentialConnectionsPostResponse,
    DetailRecordsSearchResponse,
    Direction1,
    Direction13,
    DocServiceDocument,
    DocumentLinksGetResponse,
    DocumentsGetResponse,
    DocumentsIdDeleteResponse,
    DocumentsIdGetResponse,
    DocumentsIdPatchResponse,
    DocumentsPostResponse,
    EnqueueRequest,
    Error,
    Errors,
    ExternalWdrGetDetailResponse,
    FaxApplicationsGetResponse,
    FaxApplicationsIdDeleteResponse,
    FaxApplicationsIdGetResponse,
    FaxApplicationsIdPatchResponse,
    FaxApplicationsPostResponse,
    FaxDelivered,
    FaxesGetResponse,
    FaxesIdActionsRefreshPostResponse,
    FaxesIdGetResponse,
    FaxesPostResponse,
    FaxFailed,
    FaxMediaProcessed,
    FaxQueued,
    FaxSendingStarted,
    Filter1,
    FilterAction,
    FilterAssociatedRecordTypeEq,
    FilterChannelTypeIdEq,
    FilterCountryCode,
    FilterFeatures,
    FilterFeatures1,
    FilterGroupBy,
    FilterNumberType,
    FilterNumberType2,
    FilterNumberType4,
    FilterPhoneNumberType,
    FilterPhoneNumberType2,
    FilterStatus,
    FilterStatus2,
    FilterStatus4,
    FilterStatus6,
    FilterStatus8,
    FilterStatus10,
    FilterStatusEq,
    FilterStatusEq2,
    FilterTags,
    FilterType1,
    FilterType3,
    FilterType5,
    FilterType7,
    FilterType9,
    FilterUsagePaymentMethod,
    FqdnConnectionsGetResponse,
    FqdnConnectionsIdDeleteResponse,
    FqdnConnectionsIdGetResponse,
    FqdnConnectionsIdPatchResponse,
    FqdnConnectionsPostResponse,
    FqdnsGetResponse,
    FqdnsIdDeleteResponse,
    FqdnsIdGetResponse,
    FqdnsIdPatchResponse,
    FqdnsPostResponse,
    GatherUsingAudioRequest,
    GatherUsingSpeakRequest,
    HangupRequest,
    InboundMessageEvent,
    InventoryCoverageGetResponse,
    IpConnectionsGetResponse,
    IpConnectionsIdDeleteResponse,
    IpConnectionsIdGetResponse,
    IpConnectionsIdPatchResponse,
    IpConnectionsPostResponse,
    IpsGetResponse,
    IpsIdDeleteResponse,
    IpsIdGetResponse,
    IpsIdPatchResponse,
    IpsPostResponse,
    JoinConferenceRequest,
    LeaveConferenceRequest,
    LeaveQueueRequest,
    LedgerBillingGroupReportsIdGetResponse,
    LedgerBillingGroupReportsPostResponse,
    ListVerificationsResponse,
    ListVerifyProfilesResponse,
    ManagedAccountsGetResponse,
    ManagedAccountsIdActionsDisablePostResponse,
    ManagedAccountsIdActionsDisablePostResponse1,
    ManagedAccountsIdActionsEnablePostResponse,
    ManagedAccountsIdActionsEnablePostResponse1,
    ManagedAccountsIdGetResponse,
    ManagedAccountsPostResponse,
    ManagedAccountsPostResponse1,
    MarkMessageAsReadRequestBody,
    MdrDeleteDetailReportResponse,
    MdrDeleteUsageReportsResponse,
    MdrGetDetailReportByIdResponse,
    MdrGetDetailReportResponse,
    MdrGetDetailResponse,
    MdrGetSyncUsageReportResponse,
    MdrGetUsageReportsByIdResponse,
    MdrGetUsageReportsResponse,
    MdrMessageBodyResponse,
    MdrPostDetailReportRequest,
    MdrPostDetailReportResponse,
    MdrPostUsageReportsResponse,
    MediaGetResponse,
    MediaMediaNameGetResponse,
    MediaMediaNamePutResponse,
    MediaPostResponse,
    MessagesIdGetResponse,
    MessagesLongCodePostResponse,
    MessagesNumberPoolPostResponse,
    MessagesPostResponse,
    MessagesShortCodePostResponse,
    MessageStatus,
    MessageType,
    MessageType3,
    MessagingHostedNumberOrdersGetResponse,
    MessagingHostedNumberOrdersIdActionsFileUploadPostResponse,
    MessagingHostedNumberOrdersIdGetResponse,
    MessagingHostedNumberOrdersPostResponse,
    MessagingHostedNumbersIdDeleteResponse,
    MessagingProfileMetricsGetResponse,
    MessagingProfilesGetResponse,
    MessagingProfilesIdDeleteResponse,
    MessagingProfilesIdGetResponse,
    MessagingProfilesIdMetricsGetResponse,
    MessagingProfilesIdPatchResponse,
    MessagingProfilesIdPhoneNumbersGetResponse,
    MessagingProfilesIdShortCodesGetResponse,
    MessagingProfilesPostResponse,
    MessagingUrlDomainsGetResponse,
    MobileOperatorNetworksGetResponse,
    NewBillingGroup,
    NewLedgerBillingGroupReport,
    NotificationChannel,
    NotificationChannelsGetResponse,
    NotificationChannelsIdDeleteResponse,
    NotificationChannelsIdGetResponse,
    NotificationChannelsIdPatchResponse,
    NotificationChannelsPostResponse,
    NotificationEventConditionsGetResponse,
    NotificationEventsGetResponse,
    NotificationProfile,
    NotificationProfilesGetResponse,
    NotificationProfilesIdDeleteResponse,
    NotificationProfilesIdGetResponse,
    NotificationProfilesIdPatchResponse,
    NotificationProfilesPostResponse,
    NotificationSetting,
    NotificationSettingsGetResponse,
    NotificationSettingsIdDeleteResponse,
    NotificationSettingsIdGetResponse,
    NotificationSettingsPostResponse,
    NumberBlockOrdersGetResponse,
    NumberBlockOrdersNumberBlockOrderIdGetResponse,
    NumberBlockOrdersPostResponse,
    NumberLookupPhoneNumberGetResponse,
    NumberOrderBlockEvent,
    NumberOrderDocumentsGetResponse,
    NumberOrderDocumentsNumberOrderDocumentIdGetResponse,
    NumberOrderDocumentsNumberOrderDocumentIdPatchResponse,
    NumberOrderDocumentsPostResponse,
    NumberOrderedEvent,
    NumberOrderPhoneNumbersGetResponse,
    NumberOrderPhoneNumbersNumberOrderPhoneNumberIdGetResponse,
    NumberOrderPhoneNumbersNumberOrderPhoneNumberIdPatchResponse,
    NumberOrdersGetResponse,
    NumberOrdersNumberOrderIdGetResponse,
    NumberOrdersNumberOrderIdPatchResponse,
    NumberOrdersPostResponse,
    NumberReservationsGetResponse,
    NumberReservationsNumberReservationIdActionsExtendPostResponse,
    NumberReservationsNumberReservationIdGetResponse,
    NumberReservationsPostResponse,
    OtaUpdatesGetResponse,
    OtaUpdatesIdGetResponse,
    OutboundMessageEvent,
    OutboundVoiceProfilesGetResponse,
    OutboundVoiceProfilesIdDeleteResponse,
    OutboundVoiceProfilesIdGetResponse,
    OutboundVoiceProfilesIdPatchResponse,
    OutboundVoiceProfilesPostResponse,
    PauseRecordingRequest,
    PhoneNumberBlocksJobDeletePhoneNumberBlockRequest,
    PhoneNumberBlocksJobsDeletePhoneNumberBlockPostResponse,
    PhoneNumberBlocksJobsGetResponse,
    PhoneNumberBlocksJobsIdGetResponse,
    PhoneNumberEnableEmergencyRequest,
    PhoneNumbersCsvDownloadsGetResponse,
    PhoneNumbersCsvDownloadsIdGetResponse,
    PhoneNumbersCsvDownloadsPostResponse,
    PhoneNumbersGetResponse,
    PhoneNumbersIdActionsEnableEmergencyPostResponse,
    PhoneNumbersIdDeleteResponse,
    PhoneNumbersIdGetResponse,
    PhoneNumbersIdMessagingGetResponse,
    PhoneNumbersIdMessagingPatchResponse,
    PhoneNumbersIdPatchResponse,
    PhoneNumbersIdVoiceGetResponse,
    PhoneNumbersIdVoicePatchResponse,
    PhoneNumbersInboundChannelsGetResponse,
    PhoneNumbersInboundChannelsPatchRequest,
    PhoneNumbersInboundChannelsPatchResponse,
    PhoneNumbersInboundChannelsPatchResponse1,
    PhoneNumbersJobDeletePhoneNumbersRequest,
    PhoneNumbersJobsDeletePhoneNumbersPostResponse,
    PhoneNumbersJobsGetResponse,
    PhoneNumbersJobsIdGetResponse,
    PhoneNumbersJobsUpdateEmergencySettingsPostResponse,
    PhoneNumbersJobsUpdatePhoneNumbersPostResponse,
    PhoneNumbersJobUpdateEmergencySettingsRequest,
    PhoneNumbersJobUpdatePhoneNumbersRequest,
    PhoneNumbersMessagingGetResponse,
    PhoneNumbersVoiceGetResponse,
    PlayAudioUrlRequest,
    PlaybackStopRequest,
    PortabilityChecksPostRequest,
    PortabilityChecksPostResponse,
    PortabilityStatus,
    PortingOrdersExceptionTypesGetResponse,
    PortingOrdersGetResponse,
    PortingOrdersIdActionsActivatePostResponse,
    PortingOrdersIdActionsCancelPostResponse,
    PortingOrdersIdActionsConfirmPostResponse,
    PortingOrdersIdActivationJobsActivationJobIdGetResponse,
    PortingOrdersIdActivationJobsGetResponse,
    PortingOrdersIdCommentsGetResponse,
    PortingOrdersIdCommentsPostResponse,
    PortingOrdersIdDeleteResponse,
    PortingOrdersIdGetResponse,
    PortingOrdersIdPatchResponse,
    PortingOrdersPostResponse,
    PortingOrderStatus,
    PortingOrderType,
    PortingPhoneNumbersGetResponse,
    PortoutsGetResponse,
    PortoutsIdCommentsGetResponse,
    PortoutsIdCommentsPostRequest,
    PortoutsIdCommentsPostResponse,
    PortoutsIdGetResponse,
    PortoutsIdStatusPatchResponse,
    PrivateWirelessGatewaysGetResponse,
    PrivateWirelessGatewaysIdDeleteResponse,
    PrivateWirelessGatewaysIdGetResponse,
    PrivateWirelessGatewaysPostRequest,
    PrivateWirelessGatewaysPostResponse,
    Product,
    ProductBreakdown,
    Profiles,
    QueuesQueueNameCallsCallControlIdGetResponse,
    QueuesQueueNameCallsGetResponse,
    QueuesQueueNameGetResponse,
    RecordingsGetResponse,
    RecordingsIdGetResponse,
    ReferRequest,
    RefreshRoomClientTokenRequest,
    RejectRequest,
    ReplacedLinkClickEvent,
    RequirementsGetResponse,
    RequirementsIdGetResponse,
    RequirementTypesGetResponse,
    RequirementTypesIdGetResponse,
    ResumeRecordingRequest,
    RetrieveVerificationResponse,
    RoomParticipantsGetResponse,
    RoomParticipantsRoomParticipantIdGetResponse,
    RoomSessionsGetResponse,
    RoomSessionsRoomSessionIdGetResponse,
    RoomSessionsRoomSessionIdParticipantsGetResponse,
    RoomsGetResponse,
    RoomsPostResponse,
    RoomsRoomIdActionsGenerateJoinClientTokenPostResponse,
    RoomsRoomIdActionsRefreshClientTokenPostResponse,
    RoomsRoomIdGetResponse,
    RoomsRoomIdSessionsGetResponse,
    SendDTMFRequest,
    SendFaxRequest,
    ShortCodesGetResponse,
    ShortCodesIdGetResponse,
    ShortCodesIdPatchResponse,
    SIMCard,
    SimCardGroupActionsGetResponse,
    SimCardGroupActionsIdGetResponse,
    SIMCardGroupCreate,
    SIMCardGroupPatch,
    SimCardGroupsGetResponse,
    SimCardGroupsIdActionsRemovePrivateWirelessGatewayPostResponse,
    SimCardGroupsIdActionsSetPrivateWirelessGatewayPostRequest,
    SimCardGroupsIdActionsSetPrivateWirelessGatewayPostResponse,
    SimCardGroupsIdDeleteResponse,
    SimCardGroupsIdGetResponse,
    SimCardGroupsIdPatchResponse,
    SimCardGroupsPostResponse,
    SimCardOrderCreate,
    SimCardOrderPreviewPostRequest,
    SimCardOrderPreviewPostResponse,
    SimCardOrdersGetResponse,
    SimCardOrdersIdGetResponse,
    SimCardOrdersPostResponse,
    SIMCardRegistration,
    SIMCardRegistrationCodeValidations,
    SimCardsActionsValidateRegistrationCodesPostRequest,
    SimCardsGetResponse,
    SimCardsIdActionsDisablePostResponse,
    SimCardsIdActionsEnablePostResponse,
    SimCardsIdActionsSetStandbyPostResponse,
    SimCardsIdDeleteResponse,
    SimCardsIdGetResponse,
    SimCardsIdPatchResponse,
    SimCardsSimCardIdNetworkPreferencesDeleteResponse,
    SimCardsSimCardIdNetworkPreferencesGetResponse,
    SimCardsSimCardIdNetworkPreferencesPutRequest,
    SimCardsSimCardIdNetworkPreferencesPutResponse,
    SimCardsSimCardIdPublicIpDeleteResponse,
    SimCardsSimCardIdPublicIpGetResponse,
    SimCardsSimCardIdPublicIpPostResponse,
    SimCardsSimCardIdWirelessConnectivityLogsGetResponse,
    Sort,
    Sort2,
    Sort4,
    Sort10,
    Sort11,
    Sort17,
    Sort19,
    Sort20,
    Sort22,
    Sort24,
    Sort26,
    Sort28,
    Sort30,
    Sort32,
    Sort33,
    Sort35,
    Sort37,
    SpeakRequest,
    StartForkingRequest,
    StartRecordingRequest,
    Status55,
    Status56,
    StopForkingRequest,
    StopGatherRequest,
    StopRecordingRequest,
    SubNumberOrdersGetResponse,
    SubNumberOrdersSubNumberOrderIdGetResponse,
    SubNumberOrdersSubNumberOrderIdPatchResponse,
    TelephonyCredentialCreateRequest,
    TelephonyCredentialsGetResponse,
    TelephonyCredentialsIdActionsActionPostResponse,
    TelephonyCredentialsIdDeleteResponse,
    TelephonyCredentialsIdGetResponse,
    TelephonyCredentialsIdPatchResponse,
    TelephonyCredentialsPostResponse,
    TelephonyCredentialsTagsGetResponse,
    TelephonyCredentialUpdateRequest,
    TexmlApplicationsGetResponse,
    TexmlApplicationsIdDeleteResponse,
    TexmlApplicationsIdGetResponse,
    TexmlApplicationsIdPatchResponse,
    TexmlApplicationsPostResponse,
    TimeFrame,
    TranscriptionEvent,
    TranscriptionStartRequest,
    TranscriptionStopRequest,
    TransferCallRequest,
    Type18,
    UpdateAuthenticationProviderRequest,
    UpdateBillingGroup,
    UpdateCallControlApplicationRequest,
    UpdateConferenceRequest,
    UpdateCredentialConnectionRequest,
    UpdateFaxApplicationRequest,
    UpdateFqdnConnectionRequest,
    UpdateFqdnRequest,
    UpdateIpConnectionRequest,
    UpdateIpRequest,
    UpdateMediaRequest,
    UpdateMessagingProfileRequest,
    UpdateNumberOrderDocumentRequest,
    UpdateNumberOrderPhoneNumberRequest,
    UpdateNumberOrderRequest,
    UpdateOutboundVoiceProfileRequest,
    UpdatePhoneNumberMessagingSettingsRequest,
    UpdatePhoneNumberRequest,
    UpdatePhoneNumberVoiceSettingsRequest,
    UpdatePortingOrder,
    UpdateShortCodeRequest,
    UpdateSubNumberOrderRequest,
    UpdateTexmlApplicationRequest,
    UpdateUserRequest,
    UploadMediaRequest,
    ValidateAddressRequest,
    VerifyProfileResponseDataWrapper,
    VerifyProfilesPostRequest,
    VerifyProfilesVerifyProfileIdPatchRequest,
    VerifyVerificationCodeRequest,
    VerifyVerificationCodeResponse,
    WdrReportRequest,
    WebhookDeliveriesGetResponse,
    WebhookDeliveriesIdGetResponse,
    WhatsappContactsPostResponse,
    WhatsAppDetailReportResponse,
    WhatsAppGetAllDetailReportResponse,
    WhatsappMediaPostResponse,
    WhatsappMessagesPostResponse,
    WhatsAppReportsReq,
    WhatsAppUsageAggregationsResponseContainer,
    WhatsappUsersWhatsappUserIdGetResponse,
    WirelessDetailRecordsReportsGetResponse,
    WirelessDetailRecordsReportsIdDeleteResponse,
    WirelessDetailRecordsReportsIdGetResponse,
    WirelessDetailRecordsReportsPostResponse,
)

app = MCPProxy(
    contact={'email': 'support@telnyx.com'},
    description='SIP trunking, SMS, MMS, Call Control and Telephony Data Services.',
    license={'name': 'MIT'},
    title='Telnyx API',
    version='2.0.0',
    servers=[
        {
            'description': 'Version 2.0.0 of the Telnyx API',
            'url': 'https://api.telnyx.com/v2',
        }
    ],
)


@app.delete(
    '/actions/bulk/telephony_credentials',
    description=""" Delete several credentials in bulk. """,
    tags=['telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_bulk_telephony_credential(
    filter_tag_: str = Query(..., alias='filter[tag]')
):
    """
    Delete several credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/actions/bulk/telephony_credentials',
    description=""" Update several credentials in bulk. """,
    tags=[
        'telephony_credential_management',
        'connection_management',
        'authentication_provider_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_bulk_telephony_credential(
    filter_tag_: str = Query(..., alias='filter[tag]'),
    body: BulkCredentialRequest = ...,
):
    """
    Update several credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/actions/bulk/telephony_credentials',
    description=""" Creates several credentials in bulk. """,
    tags=['connection_management', 'authentication_provider_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_bulk_telephony_credential(body: BulkCredentialRequest):
    """
    Creates several credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/actions/network_preferences/sim_cards',
    description=""" This API allows dispatching the same operation described for the PUT sim_cards/:sim_card_id/network_preferences API for multiple SIM cards at once.<br/><br/>
Although, a SIM card network preference may fail individually under any validation triggered as a consequence of its state. For example, a SIM can't have an in-progress OTA update for applying a Network Preference, so they'll fail when requested in this API. In that scenario, the specific error will be present in the response along with the successful definitions in the "errors" response node.
 """,
    tags=['network_preferences_management', 'sim_card_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bulk_s_i_m_card_network_preferences(
    body: ActionsNetworkPreferencesSimCardsPutRequest = None,
):
    """
    Bulk Network Preferences for SIM cards
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/actions/register/sim_cards',
    description=""" Register the SIM cards associated with the provided registration codes to the current user's account.<br/><br/>
If <code>sim_card_group_id</code> is provided, the SIM cards will be associated with that group. Otherwise, the default group for the current user will be used.<br/><br/>
 """,
    tags=['sim_card_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_register(body: SIMCardRegistration):
    """
    Register SIM cards
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/actions/{action}/telephony_credentials',
    description=""" Perform activate or deactivate action on all credentials filtered by the provided tag. Activate action will change the status to active, making it possible to connect calls with the credential. Deactivate action will change the status to inactive, making it impossible to connect calls with the credential. """,
    tags=['connection_management', 'managed_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bulk_credential_action(
    action: Action1, filter_tag_: str = Query(..., alias='filter[tag]')
):
    """
    Perform activate or deactivate action on all credentials filtered by the provided tag.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/addresses',
    description=""" Returns a list of your addresses. """,
    tags=['address_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def find_addresss(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_customer_reference__eq_: Optional[str] = Query(
        None, alias='filter[customer_reference][eq]'
    ),
    filter_customer_reference__contains_: Optional[str] = Query(
        None, alias='filter[customer_reference][contains]'
    ),
    filter_used_as_emergency_: Optional[str] = Query(
        'null', alias='filter[used_as_emergency]'
    ),
    filter_street_address__contains_: Optional[str] = Query(
        'null', alias='filter[street_address][contains]'
    ),
    filter_address_book__eq_: Optional[str] = Query(
        'null', alias='filter[address_book][eq]'
    ),
    sort: Optional[Sort] = 'created_at',
):
    """
    List all addresses
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/addresses',
    description=""" Creates an address. """,
    tags=['address_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_address(body: AddressCreate):
    """
    Creates an address
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/addresses/actions/validate',
    description=""" Validates an address for emergency services. """,
    tags=['address_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def validate_address(body: ValidateAddressRequest):
    """
    Validate an address
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/addresses/{id}',
    description=""" Deletes an existing address. """,
    tags=['address_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_address(id: str):
    """
    Deletes an address
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/addresses/{id}',
    description=""" Retrieves the details of an existing address. """,
    tags=['address_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_address(id: str):
    """
    Retrieve an address
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/authentication_providers',
    description=""" Returns a list of your SSO authentication providers. """,
    tags=['authentication_provider_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def find_authentication_providers(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    sort: Optional[Sort2] = '-created_at',
):
    """
    List all SSO authentication providers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/authentication_providers',
    description=""" Creates an authentication provider. """,
    tags=['authentication_provider_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_authentication_provider(body: AuthenticationProviderCreate):
    """
    Creates an authentication provider
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/authentication_providers/{id}',
    description=""" Deletes an existing authentication provider. """,
    tags=['authentication_provider_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_authentication_provider(id: str):
    """
    Deletes an authentication provider
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/authentication_providers/{id}',
    description=""" Retrieves the details of an existing authentication provider. """,
    tags=['authentication_provider_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_authentication_provider(id: str):
    """
    Retrieve an authentication provider
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/authentication_providers/{id}',
    description=""" Updates settings of an existing authentication provider. """,
    tags=['authentication_provider_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_authentication_provider(
    id: str, body: UpdateAuthenticationProviderRequest = ...
):
    """
    Update a authentication provider
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/available_phone_number_blocks',
    tags=[
        'phone_number_management',
        'phone_number_block_management',
        'number_block_order_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_available_phone_number_blocks(
    filter_phone_number__starts_with_: Optional[str] = Query(
        None, alias='filter[phone_number][starts_with]'
    ),
    filter_phone_number__ends_with_: Optional[str] = Query(
        None, alias='filter[phone_number][ends_with]'
    ),
    filter_phone_number__contains_: Optional[str] = Query(
        None, alias='filter[phone_number][contains]'
    ),
    filter_locality_: Optional[str] = Query(None, alias='filter[locality]'),
    filter_administrative_area_: Optional[str] = Query(
        None, alias='filter[administrative_area]'
    ),
    filter_country_code_: Optional[str] = Query(None, alias='filter[country_code]'),
    filter_national_destination_code_: Optional[str] = Query(
        None, alias='filter[national_destination_code]'
    ),
    filter_rate_center_: Optional[str] = Query(None, alias='filter[rate_center]'),
    filter_number_type_: Optional[FilterNumberType] = Query(
        None, alias='filter[number_type]'
    ),
    filter_features_: Optional[FilterFeatures] = Query(None, alias='filter[features]'),
    filter_minimum_block_size_: Optional[int] = Query(
        None, alias='filter[minimum_block_size]'
    ),
    filter_limit_: Optional[int] = Query(None, alias='filter[limit]'),
):
    """
    List available phone number blocks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/available_phone_numbers',
    tags=[
        'phone_number_management',
        'number_lookup_management',
        'phone_number_block_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_available_phone_numbers(
    filter_phone_number__starts_with_: Optional[str] = Query(
        None, alias='filter[phone_number][starts_with]'
    ),
    filter_phone_number__ends_with_: Optional[str] = Query(
        None, alias='filter[phone_number][ends_with]'
    ),
    filter_phone_number__contains_: Optional[str] = Query(
        None, alias='filter[phone_number][contains]'
    ),
    filter_locality_: Optional[str] = Query(None, alias='filter[locality]'),
    filter_administrative_area_: Optional[str] = Query(
        None, alias='filter[administrative_area]'
    ),
    filter_country_code_: Optional[str] = Query(None, alias='filter[country_code]'),
    filter_national_destination_code_: Optional[str] = Query(
        None, alias='filter[national_destination_code]'
    ),
    filter_rate_center_: Optional[str] = Query(None, alias='filter[rate_center]'),
    filter_number_type_: Optional[FilterNumberType2] = Query(
        None, alias='filter[number_type]'
    ),
    filter_features_: Optional[FilterFeatures1] = Query(None, alias='filter[features]'),
    filter_limit_: Optional[int] = Query(None, alias='filter[limit]'),
    filter_best_effort_: Optional[bool] = Query(None, alias='filter[best_effort]'),
    filter_quickship_: Optional[bool] = Query(None, alias='filter[quickship]'),
    filter_reservable_: Optional[bool] = Query(None, alias='filter[reservable]'),
    filter_exclude_held_numbers_: Optional[bool] = Query(
        None, alias='filter[exclude_held_numbers]'
    ),
):
    """
    List available phone numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/balance',
    tags=['request_management', 'user_management', 'billing_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_user_balance():
    """
    Retrieve user balance details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/billing_groups',
    tags=['billing_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_billing_groups(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List all billing groups
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/billing_groups',
    tags=['billing_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_billing_group(body: NewBillingGroup):
    """
    Create a billing group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/billing_groups/{id}',
    tags=['billing_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_billing_group(id: UUID):
    """
    Delete a billing group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/billing_groups/{id}',
    tags=['billing_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_billing_group(id: UUID):
    """
    Retrieve a billing group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/billing_groups/{id}',
    tags=['billing_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_billing_group(id: UUID, body: UpdateBillingGroup = ...):
    """
    Update a billing group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/call_control_applications',
    description=""" Return a list of call control applications. """,
    tags=['call_control_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_call_control_applications(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_application_name__contains_: Optional[str] = Query(
        'null', alias='filter[application_name][contains]'
    ),
    filter_outbound_voice_profile_id_: Optional[str] = Query(
        None, alias='filter[outbound_voice_profile_id]'
    ),
    sort: Optional[Sort4] = 'created_at',
):
    """
    List call control applications
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/call_control_applications',
    description=""" Create a call control application. """,
    tags=['call_control_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_call_control_application(body: CreateCallControlApplicationRequest):
    """
    Create a call control application
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/call_control_applications/{id}',
    description=""" Deletes a call control application. """,
    tags=['call_control_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_call_control_application(id: str):
    """
    Delete a call control application
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/call_control_applications/{id}',
    description=""" Retrieves the details of an existing call control application. """,
    tags=['call_control_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_call_control_application(id: str):
    """
    Retrieve a call control application
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/call_control_applications/{id}',
    description=""" Updates settings of an existing call control application. """,
    tags=['call_control_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_call_control_application(
    id: str, body: UpdateCallControlApplicationRequest = ...
):
    """
    Update a call control application
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/call_events',
    description=""" Filters call events by given filter parameters. Events are ordered by `event_timestamp`. If filter for `call_leg_id` or `call_session_id` is not present, it only filters events from the last 24 hours.

**Note**: Only one `filter[event_timestamp]` can be passed.
 """,
    tags=['call_event_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_call_events(
    filter_call_leg_id_: Optional[UUID] = Query(None, alias='filter[call_leg_id]'),
    filter_call_session_id_: Optional[UUID] = Query(
        None, alias='filter[call_session_id]'
    ),
    filter_status_: Optional[FilterStatus] = Query(None, alias='filter[status]'),
    filter_type_: Optional[FilterType1] = Query(None, alias='filter[type]'),
    filter_event_timestamp__gt_: Optional[str] = Query(
        None, alias='filter[event_timestamp][gt]'
    ),
    filter_event_timestamp__gte_: Optional[str] = Query(
        None, alias='filter[event_timestamp][gte]'
    ),
    filter_event_timestamp__lt_: Optional[str] = Query(
        None, alias='filter[event_timestamp][lt]'
    ),
    filter_event_timestamp__lte_: Optional[str] = Query(
        None, alias='filter[event_timestamp][lte]'
    ),
    filter_event_timestamp__eq_: Optional[str] = Query(
        None, alias='filter[event_timestamp][eq]'
    ),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List call events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls',
    description=""" Dial a number or SIP URI from a given connection. A successful response will include a `call_leg_id` which can be used to correlate the command with subsequent webhooks.

**Expected Webhooks:**

- `call.initiated`
- `call.answered` or `call.hangup`
- `call.machine.detection.ended` if `answering_machine_detection` was requested
- `call.machine.greeting.ended` if `answering_machine_detection` was set to `detect_beep`, `greeting_end` or `detect_words` """,
    tags=['call_management', 'call_control_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_dial(body: CallRequest):
    """
    Dial
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calls/{call_control_id}',
    description=""" Returns the status of a call (data is available 10 minutes after call ended). """,
    tags=[
        'call_management',
        'call_event_management',
        'call_control_application_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_call_status(call_control_id: str):
    """
    Retrieve a call status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/answer',
    description=""" Answer an incoming call. You must issue this command before executing subsequent commands on an incoming call.

**Expected Webhooks:**

- `call.answered`
 """,
    tags=['call_management', 'call_control_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_answer(call_control_id: str, body: AnswerRequest = ...):
    """
    Answer call
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/bridge',
    description=""" Bridge two call control calls.

**Expected Webhooks:**

- `call.bridged` for Leg A
- `call.bridged` for Leg B
 """,
    tags=[
        'call_management',
        'call_control_application_management',
        'conference_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_bridge(call_control_id: str, body: BridgeRequest = ...):
    """
    Bridge calls
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/enqueue',
    description=""" Put the call in a queue. """,
    tags=['call_queue_management', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_enqueue(call_control_id: str, body: EnqueueRequest = ...):
    """
    Enqueue call
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/fork_start',
    description=""" Call forking allows you to stream the media from a call to a specific target in realtime. 
This stream can be used to enable realtime audio analysis to support a 
variety of use cases, including fraud detection, or the creation of AI-generated audio responses. 
Requests must specify either the `target` attribute or the `rx` and `tx` attributes.

**Expected Webhooks:**

- `call.fork.started`
- `call.fork.stopped`

**Simple Telnyx RTP Encapsulation Protocol (STREP)**

*Note: This header/encapsulation is not used when the `rx` and `tx`
parameters have been specified; it only applies when media is forked
using the `target` attribute.*

If the destination for forked media is specified using the "target"
attribute, the RTP will be encapsulated in an extra Telnyx protocol,
which adds a 24 byte header to the RTP payload in each packet. The STREP
header includes the Call Control `call_leg_id` for stream
identification, along with bits that represent the direction (inbound or
outbound) of the media. This 24-byte header sits between the UDP header
and the RTP header.

The STREP header makes it possible to fork RTP for multiple calls (or
two RTP streams for the same call) to the same IP:port, where the
streams can be demultiplexed by your application using the information
in the header. Of course, it's still possible to ignore this header
completely, for example, if sending forked media for different calls to
different ports or IP addresses. In this case, simply strip 24 bytes
(or use the second byte to find the header length) from the received UDP
payload to get the RTP (RTP header and payload).

```
STREP Specification

  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |1 1|Version|L|D|    HeaderLen  |  reserved (2 bytes)           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |       reserved (4 bytes, for UDP ports or anything else)      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |               The call_leg_id                                 |
 |                   from Call Control                           |
 |                       (128 bits / 16 bytes)                   |
 |                           (this is binary data)               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 11
   Static bits 11, always set to 11 to easily distinguish forked media
   from RTP (10) and T.38 media (usually 00) and SIP (which begins
   with a capital letter, so begins with bits 01). This is a magic number.

 Version
   Four bits to indicate the version number of the protocol, starting at 0001.

 L
   One bit to represent the leg of the call (A or B).
   0 represents the A (first) leg of the call.
   1 represents the B (second) leg of the call.

 D
   One bit to represent the direction of this RTP stream.
   0 represents media received by Telnyx.
   1 represents media transmitted by Telnyx.

 HeaderLen (1 byte)
   The length of the header in bytes.
   Note that this value does not include the length of the payload. The total
   size of the RTP can be calculated by subtracting the HeaderLen from the UDP
   length (minus 8 for the UDP header).
   In version 1, this value will always be 24.

 Reserved (6 bytes)
   Reserved for future use and to make sure that the header is a multiple of 32 bits

 Call Leg ID
   A 128-bit identifier for the call leg.
   This is the call_leg_id from Call Control.
```
 """,
    tags=[
        'call_control_application_management',
        'call_management',
        'conference_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_fork_start(call_control_id: str, body: StartForkingRequest = ...):
    """
    Forking start
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/fork_stop',
    description=""" Stop forking a call.

**Expected Webhooks:**

- `call.fork.stopped`
 """,
    tags=['call_control_application_management', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_fork_stop(call_control_id: str, body: StopForkingRequest = ...):
    """
    Forking stop
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/gather_stop',
    description=""" Stop current gather.

**Expected Webhooks:**

- `call.gather.ended`
 """,
    tags=['call_gathering', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_gather_stop(call_control_id: str, body: StopGatherRequest = ...):
    """
    Gather stop
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/gather_using_audio',
    description=""" Play an audio file on the call until the required DTMF signals are gathered to build interactive menus.

You can pass a list of valid digits along with an 'invalid_audio_url', which will be played back at the beginning of each prompt. Playback will be interrupted when a DTMF signal is received. The [Answer](/docs/api/v2/call-control/Call-Commands#CallControlAnswer) command must be issued before the `gather_using_audio` command.

**Expected Webhooks:**

- `call.playback.started`
- `call.playback.ended`
- `call.dtmf.received` (you may receive many of these webhooks)
- `call.gather.ended`
 """,
    tags=['call_gathering', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_gather_using_audio(call_control_id: str, body: GatherUsingAudioRequest = ...):
    """
    Gather using audio
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/gather_using_speak',
    description=""" Convert text to speech and play it on the call until the required DTMF signals are gathered to build interactive menus.

You can pass a list of valid digits along with an 'invalid_payload', which will be played back at the beginning of each prompt. Speech will be interrupted when a DTMF signal is received. The [Answer](/docs/api/v2/call-control/Call-Commands#CallControlAnswer) command must be issued before the `gather_using_speak` command.

**Expected Webhooks:**

- `call.dtmf.received` (you may receive many of these webhooks)
- `call.gather.ended`
 """,
    tags=['call_gathering', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_gather_using_speak(call_control_id: str, body: GatherUsingSpeakRequest = ...):
    """
    Gather using speak
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/hangup',
    description=""" Hang up the call.

**Expected Webhooks:**

- `call.hangup`
- `call.recording.saved`
 """,
    tags=['call_management', 'call_control_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_hangup(call_control_id: str, body: HangupRequest = ...):
    """
    Hangup call
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/leave_queue',
    description=""" Removes the call from a queue. """,
    tags=['call_queue_management', 'call_queue_operations', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def leave_queue(call_control_id: str, body: LeaveQueueRequest = ...):
    """
    Remove call from a queue
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/playback_start',
    description=""" Play an audio file on the call. If multiple play audio commands are issued consecutively,
the audio files will be placed in a queue awaiting playback.

*Notes:*

- When `overlay` is enabled, `target_legs` is limited to `self`.
- A customer cannot Play Audio with `overlay=true` unless there is a Play Audio with `overlay=false` actively playing.

**Expected Webhooks:**

- `call.playback.started`
- `call.playback.ended`
 """,
    tags=[
        'call_management',
        'call_control_application_management',
        'conference_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_playback_start(call_control_id: str, body: PlayAudioUrlRequest = ...):
    """
    Play audio URL
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/playback_stop',
    description=""" Stop audio being played on the call.

**Expected Webhooks:**

- `call.playback.ended` or `call.speak.ended`
 """,
    tags=['call_management', 'call_control_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_playback_stop(call_control_id: str, body: PlaybackStopRequest = ...):
    """
    Stop audio playback
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/record_pause',
    description=""" Pause recording the call. Recording can be resumed via Resume recording command.

**Expected Webhooks:**

There are no webhooks associated with this command.
 """,
    tags=['call_management', 'call_recording_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_record_pause(call_control_id: str, body: PauseRecordingRequest = ...):
    """
    Record pause
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/record_resume',
    description=""" Resume recording the call.

**Expected Webhooks:**

There are no webhooks associated with this command.
 """,
    tags=['call_management', 'call_recording_management', 'recording_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_record_resume(call_control_id: str, body: ResumeRecordingRequest = ...):
    """
    Record resume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/record_start',
    description=""" Start recording the call. Recording will stop on call hang-up, or can be initiated via the Stop Recording command.

**Expected Webhooks:**

- `call.recording.saved`
 """,
    tags=['call_management', 'call_recording_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_record_start(call_control_id: str, body: StartRecordingRequest = ...):
    """
    Recording start
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/record_stop',
    description=""" Stop recording the call.

**Expected Webhooks:**

- `call.recording.saved`
 """,
    tags=['call_management', 'call_recording_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_record_stop(call_control_id: str, body: StopRecordingRequest = ...):
    """
    Recording stop
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/refer',
    description=""" Initiate a SIP Refer on a Call Control call. You can initiate a SIP Refer at any point in the duration of a call.

**Expected Webhooks:**

- `call.refer.started`
- `call.refer.completed`
- `call.refer.failed`
 """,
    tags=['call_management', 'call_control_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_refer(call_control_id: str, body: ReferRequest = ...):
    """
    SIP Refer a call
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/reject',
    description=""" Reject an incoming call.

**Expected Webhooks:**

- `call.hangup`
 """,
    tags=['call_management', 'call_control_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_reject(call_control_id: str, body: RejectRequest = ...):
    """
    Reject a call
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/send_dtmf',
    description=""" Sends DTMF tones from this leg. DTMF tones will be heard by the other end of the call.

**Expected Webhooks:**

There are no webhooks associated with this command.
 """,
    tags=['call_management', 'call_gathering'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_send_d_t_m_f(call_control_id: str, body: SendDTMFRequest = ...):
    """
    Send DTMF
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/speak',
    description=""" Convert text to speech and play it back on the call. If multiple speak text commands are issued consecutively, the audio files will be placed in a queue awaiting playback.

**Expected Webhooks:**

- `call.speak.started`
- `call.speak.ended`
 """,
    tags=['call_management', 'call_gathering'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_speak(call_control_id: str, body: SpeakRequest = ...):
    """
    Speak text
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/transcription_start',
    description=""" Start real-time transcription. Transcription will stop on call hang-up, or can be initiated via the Transcription stop command. """,
    tags=['call_transcription', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_transcription_start(
    call_control_id: str, body: TranscriptionStartRequest = ...
):
    """
    Transcription start
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/transcription_stop',
    description=""" Stop real-time transcription. """,
    tags=['call_recording_management', 'call_transcription', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_transcription_stop(call_control_id: str, body: TranscriptionStopRequest = ...):
    """
    Transcription stop
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/{call_control_id}/actions/transfer',
    description=""" Transfer a call to a new destination. If the transfer is unsuccessful, a `call.hangup` webhook for the other call (Leg B) will be sent indicating that the transfer could not be completed. The original call will remain active and may be issued additional commands, potentially transfering the call to an alternate destination.

**Expected Webhooks:**

- `call.initiated`
- `call.bridged` to Leg B
- `call.answered` or `call.hangup`
- `call.machine.detection.ended` if `answering_machine_detection` was requested
- `call.machine.greeting.ended` if `answering_machine_detection` was set to `detect_beep`, `greeting_end` or `detect_words` """,
    tags=['call_management', 'call_control_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def call_transfer(call_control_id: str, body: TransferCallRequest = ...):
    """
    Transfer call
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/comments',
    tags=['comment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_comments(
    filter_comment_record_type_: str = Query(..., alias='filter[comment_record_type]'),
    filter_comment_record_id_: str = Query(..., alias='filter[comment_record_id]'),
):
    """
    Retrieve all comments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/comments',
    tags=['comment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_comment(body: Comment):
    """
    Create a comment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/comments/{id}',
    tags=['comment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_comment(id: str):
    """
    Retrieve a comment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/comments/{id}/read',
    tags=['comment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def mark_comment_read(id: str):
    """
    Mark a comment as read
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/conferences',
    description=""" Lists conferences. Conferences are created on demand, and will expire after all participants have left the conference or after 4 hours regardless of the number of active participants. Conferences are listed in descending order by `expires_at`. """,
    tags=['conference_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_conferences(
    filter_name_: Optional[str] = Query(None, alias='filter[name]'),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List conferences
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences',
    description=""" Create a conference from an existing call leg using a `call_control_id` and a conference name. Upon creating the conference, the call will be automatically bridged to the conference. Conferences will expire after all participants have left the conference or after 4 hours regardless of the number of active participants.

**Expected Webhooks:**

- `conference.created`
- `conference.participant.joined`
- `conference.participant.left`
- `conference.ended`
- `conference.recording.saved`
- `conference.floor.changed`
 """,
    tags=['conference_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_conference(body: CreateConferenceRequest):
    """
    Create conference
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/conferences/{conference_id}/participants',
    description=""" Lists conference participants """,
    tags=['conference_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_conference_participants(
    conference_id: str,
    filter_muted_: Optional[bool] = Query(None, alias='filter[muted]'),
    filter_on_hold_: Optional[bool] = Query(None, alias='filter[on_hold]'),
    filter_whispering_: Optional[bool] = Query(None, alias='filter[whispering]'),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List conference participants
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/conferences/{id}',
    description=""" Retrieve an existing conference """,
    tags=['conference_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_conference(id: str):
    """
    Retrieve a conference
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/dial_participant',
    description=""" Dials a phone number and, when the call is answered, automatically joins them into the specified conference.

**Expected Webhooks:**

- `call.hangup`
- `call.answered`
- `conference.participant.joined`
- `conference.participant.left`
 """,
    tags=['call_management', 'conference_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_dial_participant_in(id: str, body: ConferenceCallRequest = ...):
    """
    Dial a new participant into a conference
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/hold',
    description=""" Hold a list of participants in a conference call """,
    tags=['conference_management', 'session_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_hold_participants(id: str, body: ConferenceHoldRequest = ...):
    """
    Hold conference participants
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/join',
    description=""" Join an existing call leg to a conference. Issue the Join Conference command with the conference ID in the path and the `call_control_id` of the leg you wish to join to the conference as an attribute.

**Expected Webhooks:**

- `conference.participant.joined`
- `conference.participant.left`
 """,
    tags=['conference_management', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_join(id: str, body: JoinConferenceRequest = ...):
    """
    Join a conference
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/leave',
    description=""" Removes a call leg from a conference and moves it back to parked state. **Expected Webhooks:**

- `conference.participant.left`
 """,
    tags=['conference_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_leave(id: str, body: LeaveConferenceRequest = ...):
    """
    Leave a conference
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/mute',
    description=""" Mute a list of participants in a conference call """,
    tags=['conference_management', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_mute_participants(id: str, body: ConferenceMuteRequest = ...):
    """
    Mute conference participants
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/play',
    description=""" Play audio to all or some participants on a conference call. """,
    tags=['conference_management', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_play_audio(id: str, body: ConferencePlayRequest = ...):
    """
    Play audio to conference participants
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/record_start',
    description=""" Start recording the conference. Recording will stop on conference end, or via the Stop Recording command.

**Expected Webhooks:**

- `conference.recording.saved` """,
    tags=['call_management', 'call_recording_management', 'conference_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_start_recording(id: str, body: StartRecordingRequest = ...):
    """
    Conference recording start
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/record_stop',
    description=""" Stop recording the conference.

**Expected Webhooks:**

- `conference.recording.saved`
 """,
    tags=['call_recording_management', 'conference_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_stop_recording(id: str, body: StopRecordingRequest = ...):
    """
    Conference recording stop
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/speak',
    description=""" Convert text to speech and play it to all or some participants. """,
    tags=['conference_management', 'call_management', 'call_gathering'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_speak_text(id: str, body: ConferenceSpeakRequest = ...):
    """
    Speak text to conference participants
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/stop',
    description=""" Stop audio being played to all or some participants on a conference call. """,
    tags=['conference_management', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_stop_audio(id: str, body: ConferenceStopRequest = ...):
    """
    Stop audio being played on the conference
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/unhold',
    description=""" Unhold a list of participants in a conference call """,
    tags=['conference_management', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_unhold_participants(id: str, body: ConferenceUnholdRequest = ...):
    """
    Unhold conference participants
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/unmute',
    description=""" Unmute a list of participants in a conference call """,
    tags=['conference_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_unmute_participants(id: str, body: ConferenceUnmuteRequest = ...):
    """
    Unmute conference participants
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/conferences/{id}/actions/update',
    description=""" Update conference participant supervisor_role """,
    tags=['conference_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def conference_update(id: str, body: UpdateConferenceRequest = ...):
    """
    Update conference participant
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/connections',
    description=""" Returns a list of your connections irrespective of type. """,
    tags=['connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_connections(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_connection_name__contains_: Optional[str] = Query(
        None, alias='filter[connection_name][contains]'
    ),
    filter_outbound_voice_profile_id_: Optional[str] = Query(
        None, alias='filter[outbound_voice_profile_id]'
    ),
    sort: Optional[Sort4] = 'created_at',
):
    """
    List connections
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/connections/{id}',
    description=""" Retrieves the high-level details of an existing connection. To retrieve specific authentication information, use the endpoint for the specific connection type. """,
    tags=['connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_connection(id: str):
    """
    Retrieve a connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/credential_connections',
    description=""" Returns a list of your credential connections. """,
    tags=['connection_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_credential_connections(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_connection_name__contains_: Optional[str] = Query(
        None, alias='filter[connection_name][contains]'
    ),
    filter_outbound_outbound_voice_profile_id_: Optional[str] = Query(
        None, alias='filter[outbound.outbound_voice_profile_id]'
    ),
    sort: Optional[Sort4] = 'created_at',
):
    """
    List credential connections
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/credential_connections',
    description=""" Creates a credential connection. """,
    tags=['connection_management', 'authentication_provider_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_credential_connection(body: CreateCredentialConnectionRequest):
    """
    Create a credential connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/credential_connections/{id}',
    description=""" Deletes an existing credential connection. """,
    tags=['connection_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_credential_connection(id: str):
    """
    Delete a credential connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/credential_connections/{id}',
    description=""" Retrieves the details of an existing credential connection. """,
    tags=['connection_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_credential_connection(id: str):
    """
    Retrieve a credential connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/credential_connections/{id}',
    description=""" Updates settings of an existing credential connection. """,
    tags=['connection_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_credential_connection(
    id: str, body: UpdateCredentialConnectionRequest = ...
):
    """
    Update a credential connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/detail_records',
    description=""" Search for any detail record across the Telnyx Platform """,
    tags=['record_search_management', 'call_event_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def detail_records_search(
    filter_record_type_: str = Query(..., alias='filter[record_type]'),
    filter_date_range_: Optional[str] = Query(None, alias='filter[date_range]'),
    filter: Optional[Filter1] = None,
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=50)] = Query(20, alias='page[size]'),
    sort: Optional[Sort10] = None,
):
    """
    Search detail records
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/document_links',
    description=""" List all documents links ordered by created_at descending. """,
    tags=['document_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_document_links(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_document_id_: Optional[UUID] = Query(None, alias='filter[document_id]'),
    filter_linked_record_type_: Optional[str] = Query(
        None, alias='filter[linked_record_type]'
    ),
    filter_linked_resource_id_: Optional[UUID] = Query(
        None, alias='filter[linked_resource_id]'
    ),
):
    """
    List all document links
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents',
    description=""" List all documents ordered by created_at descending. """,
    tags=['document_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_documents(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List all documents
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/documents',
    description=""" Upload a document.<br /><br />Uploaded files must be linked to a service within 30 minutes or they will be automatically deleted. """,
    tags=['document_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_document(body: CreateDocServiceDocumentRequest):
    """
    Upload a document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/documents/{id}',
    description=""" Delete a document.<br /><br />A document can only be deleted if it's not linked to a service. If it is linked to a service, it must be unlinked prior to deleting. """,
    tags=['document_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_document(id: UUID):
    """
    Delete a document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{id}',
    description=""" Retrieve a document. """,
    tags=['document_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_document(id: UUID):
    """
    Retrieve a document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/documents/{id}',
    description=""" Update a document. """,
    tags=['document_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_document(id: UUID, body: DocServiceDocument = ...):
    """
    Update a document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{id}/download',
    description=""" Download a document. """,
    tags=['document_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def download_doc_service_document(id: UUID):
    """
    Download a document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/fax_applications',
    description=""" This endpoint returns a list of your Fax Applications inside the 'data' attribute of the response. You can adjust which applications are listed by using filters. Fax Applications are used to configure how you send and receive faxes using the Programmable Fax API with Telnyx. """,
    tags=['fax_application_management', 'fax_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_fax_applications(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_application_name__contains_: Optional[str] = Query(
        'null', alias='filter[application_name][contains]'
    ),
    filter_outbound_voice_profile_id_: Optional[str] = Query(
        None, alias='filter[outbound_voice_profile_id]'
    ),
    sort: Optional[Sort11] = 'created_at',
):
    """
    List all Fax Applications
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/fax_applications',
    description=""" Creates a new Fax Application based on the parameters sent in the request. The application name and webhook URL are required. Once created, you can assign phone numbers to your application using the `/phone_numbers` endpoint. """,
    tags=['fax_application_management', 'fax_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_fax_application(body: CreateFaxApplicationRequest):
    """
    Creates a Fax Application
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/fax_applications/{id}',
    description=""" Permanently deletes a Fax Application. Deletion may be prevented if the application is in use by phone numbers. """,
    tags=['fax_application_management', 'fax_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_fax_application(id: str):
    """
    Deletes a Fax Application
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/fax_applications/{id}',
    description=""" Return the details of an existing Fax Application inside the 'data' attribute of the response. """,
    tags=['fax_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_fax_application(id: str):
    """
    Retrieve a Fax Application
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/fax_applications/{id}',
    description=""" Updates settings of an existing Fax Application based on the parameters of the request. """,
    tags=['fax_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_fax_application(id: str, body: UpdateFaxApplicationRequest = ...):
    """
    Update a Fax Application
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/faxes',
    tags=['fax_management', 'fax_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_faxes(
    filter_created_at__gte_: Optional[datetime_aliased] = Query(
        None, alias='filter[created_at][gte]'
    ),
    filter_created_at__gt_: Optional[datetime_aliased] = Query(
        None, alias='filter[created_at][gt]'
    ),
    filter_created_at__lte_: Optional[datetime_aliased] = Query(
        None, alias='filter[created_at][lte]'
    ),
    filter_created_at__lt_: Optional[datetime_aliased] = Query(
        None, alias='filter[created_at][lt]'
    ),
    filter_direction__eq_: Optional[str] = Query(None, alias='filter[direction][eq]'),
    filter_from__eq_: Optional[str] = Query(None, alias='filter[from][eq]'),
    page_size_: Optional[int] = Query(None, alias='page[size]'),
    page_number_: Optional[int] = Query(None, alias='page[number]'),
):
    """
    View a list of faxes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/faxes',
    tags=['fax_management', 'fax_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def send_fax(body: SendFaxRequest):
    """
    Send a fax
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/faxes/{id}',
    tags=['fax_application_management', 'fax_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_fax(id: UUID):
    """
    Delete a fax
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/faxes/{id}',
    tags=['fax_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def view_fax(id: UUID):
    """
    View a fax
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/faxes/{id}/actions/refresh',
    description=""" Refreshes the inbound fax's media_url when it has expired """,
    tags=['fax_management', 'fax_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def refresh_fax(id: UUID):
    """
    Refresh a fax
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/fqdn_connections',
    description=""" Returns a list of your FQDN connections. """,
    tags=['connection_management', 'fqdn_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_fqdn_connections(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_connection_name__contains_: Optional[str] = Query(
        None, alias='filter[connection_name][contains]'
    ),
    sort: Optional[Sort11] = 'created_at',
):
    """
    List FQDN connections
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/fqdn_connections',
    description=""" Creates a FQDN connection. """,
    tags=['connection_management', 'fqdn_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_fqdn_connection(body: CreateFqdnConnectionRequest):
    """
    Create an FQDN connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/fqdn_connections/{id}',
    description=""" Deletes an FQDN connection. """,
    tags=['fqdn_management', 'connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_fqdn_connection(id: str):
    """
    Delete an FQDN connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/fqdn_connections/{id}',
    description=""" Retrieves the details of an existing FQDN connection. """,
    tags=['connection_management', 'fqdn_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_fqdn_connection(id: str):
    """
    Retrieve an FQDN connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/fqdn_connections/{id}',
    description=""" Updates settings of an existing FQDN connection. """,
    tags=['connection_management', 'fqdn_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_fqdn_connection(id: str, body: UpdateFqdnConnectionRequest = ...):
    """
    Update an FQDN connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/fqdns',
    description=""" Get all FQDNs belonging to the user that match the given filters. """,
    tags=['fqdn_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_fqdns(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_connection_id_: Optional[str] = Query(None, alias='filter[connection_id]'),
    filter_fqdn_: Optional[str] = Query(None, alias='filter[fqdn]'),
    filter_port_: Optional[int] = Query(None, alias='filter[port]'),
    filter_dns_record_type_: Optional[str] = Query(
        None, alias='filter[dns_record_type]'
    ),
):
    """
    List FQDNs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/fqdns',
    description=""" Create a new FQDN object. """,
    tags=['fqdn_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_fqdn(body: CreateFqdnRequest = None):
    """
    Create an FQDN
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/fqdns/{id}',
    description=""" Delete an FQDN. """,
    tags=['fqdn_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_fqdn(id: str):
    """
    Delete an FQDN
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/fqdns/{id}',
    description=""" Return the details regarding a specific FQDN. """,
    tags=['fqdn_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_fqdn(id: str):
    """
    Retrieve an FQDN
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/fqdns/{id}',
    description=""" Update the details of a specific FQDN. """,
    tags=['fqdn_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_fqdn(id: str, body: UpdateFqdnRequest = None):
    """
    Update an FQDN
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/inventory_coverage',
    description=""" Creates an inventory coverage request. If locality, npa or national_destination_code is used in groupBy, and no region or locality filters are used, the whole paginated set is returned. """,
    tags=['inventory_request_management', 'phone_number_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_inventory_coverage_request(
    filter_npa_: Optional[int] = Query(None, alias='filter[npa]'),
    filter_nxx_: Optional[int] = Query(None, alias='filter[nxx]'),
    filter_administrative_area_: Optional[str] = Query(
        None, alias='filter[administrative_area]'
    ),
    filter_number_type_: Optional[FilterNumberType4] = Query(
        None, alias='filter[number_type]'
    ),
    filter_phone_number_type_: Optional[FilterPhoneNumberType] = Query(
        None, alias='filter[phone_number_type]'
    ),
    filter_country_code_: Optional[FilterCountryCode] = Query(
        None, alias='filter[country_code]'
    ),
    filter_count_: Optional[bool] = Query(None, alias='filter[count]'),
    filter_group_by_: FilterGroupBy = Query(..., alias='filter[groupBy]'),
):
    """
    Create an inventory coverage request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ip_connections',
    description=""" Returns a list of your IP connections. """,
    tags=['ip_connection_management', 'connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_ip_connections(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_connection_name__contains_: Optional[str] = Query(
        None, alias='filter[connection_name][contains]'
    ),
    filter_outbound_outbound_voice_profile_id_: Optional[str] = Query(
        None, alias='filter[outbound.outbound_voice_profile_id]'
    ),
    sort: Optional[Sort11] = 'created_at',
):
    """
    List Ip connections
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ip_connections',
    description=""" Creates an IP connection. """,
    tags=['ip_connection_management', 'connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_ip_connection(body: CreateIpConnectionRequest):
    """
    Create an Ip connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/ip_connections/{id}',
    description=""" Deletes an existing IP connection. """,
    tags=['ip_connection_management', 'connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_ip_connection(id: str):
    """
    Delete an Ip connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ip_connections/{id}',
    description=""" Retrieves the details of an existing ip connection. """,
    tags=['ip_connection_management', 'connection_management', 'ip_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_ip_connection(id: str):
    """
    Retrieve an Ip connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/ip_connections/{id}',
    description=""" Updates settings of an existing IP connection. """,
    tags=['ip_connection_management', 'connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_ip_connection(id: str, body: UpdateIpConnectionRequest = ...):
    """
    Update an Ip connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ips',
    description=""" Get all IPs belonging to the user that match the given filters. """,
    tags=['ip_management', 'ip_connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_ips(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_connection_id_: Optional[str] = Query(None, alias='filter[connection_id]'),
    filter_ip_address_: Optional[str] = Query(None, alias='filter[ip_address]'),
    filter_port_: Optional[int] = Query(None, alias='filter[port]'),
):
    """
    List Ips
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ips',
    description=""" Create a new IP object. """,
    tags=['ip_connection_management', 'ip_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_ip(body: CreateIpRequest = None):
    """
    Create an Ip
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/ips/{id}',
    description=""" Delete an IP. """,
    tags=['ip_connection_management', 'ip_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_ip(id: UUID):
    """
    Delete an Ip
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ips/{id}',
    description=""" Return the details regarding a specific IP. """,
    tags=['ip_management', 'ip_connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_ip(id: UUID):
    """
    Retrieve an Ip
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/ips/{id}',
    description=""" Update the details of a specific IP. """,
    tags=['ip_management', 'ip_connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_ip(id: UUID, body: UpdateIpRequest = None):
    """
    Update an Ip
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ledger_billing_group_reports',
    tags=['ledger_billing_reports_management', 'billing_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_ledger_billing_group_report(body: NewLedgerBillingGroupReport):
    """
    Create a ledger billing group report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ledger_billing_group_reports/{id}',
    tags=['ledger_billing_reports_management', 'billing_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_ledger_billing_group_report(id: UUID):
    """
    Retrieve a ledger billing group report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed_accounts',
    description=""" Lists the accounts managed by the current user. Users need to be explictly approved by Telnyx in order to become manager accounts. """,
    tags=['managed_account_management', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_managed_accounts(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_email__contains_: Optional[str] = Query(
        'null', alias='filter[email][contains]'
    ),
    filter_email__eq_: Optional[str] = Query('null', alias='filter[email][eq]'),
    sort: Optional[Sort17] = 'created_at',
):
    """
    Lists accounts managed by the current user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/managed_accounts',
    description=""" Create a new managed account owned by the authenticated user. You need to be explictly approved by Telnyx in order to become a manager account. """,
    tags=['managed_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_managed_account(body: CreateManagedAccountRequest):
    """
    Create a new managed account.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed_accounts/{id}',
    description=""" Retrieves the details of a single managed account. """,
    tags=['managed_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_managed_account(id: str):
    """
    Retrieve a managed account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/managed_accounts/{id}/actions/disable',
    description=""" Disables a managed account, forbidding it to use Telnyx services, including sending or receiving phone calls and SMS messages. Ongoing phone calls will not be affected. The managed account and its sub-users will still be able to log in via the mission control portal. """,
    tags=['managed_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def disable_managed_account(id: str):
    """
    Disables a managed account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/managed_accounts/{id}/actions/enable',
    description=""" Enables a managed account and its sub-users to use Telnyx services. """,
    tags=['managed_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def enable_managed_account(id: str):
    """
    Enables a managed account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/media',
    description=""" Returns a list of stored media files. """,
    tags=['media_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_media():
    """
    List uploaded media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/media',
    description=""" Upload media file to Telnyx so it can be used with other Telnyx services """,
    tags=['media_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_media(body: UploadMediaRequest):
    """
    Upload media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/media/{media_name}',
    description=""" Deletes a stored media file. """,
    tags=['media_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_media(media_name: str):
    """
    Deletes stored media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/media/{media_name}',
    description=""" Returns the information about a stored media file. """,
    tags=['media_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_media(media_name: str):
    """
    Retrieve stored media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/media/{media_name}',
    description=""" Updates a stored media file. """,
    tags=['media_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_media(media_name: str, body: UpdateMediaRequest = ...):
    """
    Update stored media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/media/{media_name}/download',
    description=""" Downloads a stored media file. """,
    tags=['media_management', 'document_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def download_media(media_name: str):
    """
    Download stored media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/message_detail_records',
    description=""" Fetch all Mdr records  """,
    tags=['record_search_management', 'messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_paginated_mdrs(
    start_date: datetime_aliased,
    end_date: datetime_aliased = ...,
    id: Optional[str] = None,
    direction: Optional[Direction1] = None,
    outbound_profile_id: Optional[str] = None,
    cld: Optional[str] = None,
    cli: Optional[str] = None,
    status: Optional[MessageStatus] = None,
    message_type: Optional[MessageType] = None,
    country_iso: Optional[str] = None,
    error: Optional[str] = None,
    normalized_carrier: Optional[str] = None,
    tag: Optional[str] = None,
    mcc: Optional[str] = None,
    mnc: Optional[str] = None,
    product: Optional[Product] = None,
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=50)] = Query(20, alias='page[size]'),
    sort: Optional[Sort19] = 'created_at',
):
    """
    Fetch messaging detail records.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/message_detail_records/{id}/message_body',
    description=""" Fetch Mdr message body  """,
    tags=['messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_mdr_message_body(id: str):
    """
    Fetch message body by id.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/messages',
    description=""" Send a message with a Phone Number, Alphanumeric Sender ID, Short Code or Number Pool.

This endpoint allows you to send a message with any messaging resource.
Current messaging resources include: long-code, short-code, number-pool, and
alphanumeric-sender-id.
 """,
    tags=['messaging_management', 'whatsapp_message_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_message(body: CreateMessageRequest = None):
    """
    Send a message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/messages/long_code',
    tags=['messaging_management', 'whatsapp_message_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_long_code_message(body: CreateLongCodeMessageRequest = None):
    """
    Send a long code message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/messages/number_pool',
    tags=['messaging_management', 'phone_number_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_number_pool_message(body: CreateNumberPoolMessageRequest = None):
    """
    Send a message using number pool
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/messages/short_code',
    tags=['messaging_management', 'short_code_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_short_code_message(body: CreateShortCodeMessageRequest = None):
    """
    Send a short code message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/messages/{id}',
    description=""" Note: This API endpoint can only retrieve messages that are no older than 10 days since their creation. If you require messages older than this, please generate an [MDR report.](https://developers.telnyx.com/docs/api/v1/reports/MDR-Reports) """,
    tags=['messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_message(id: UUID):
    """
    Retrieve a message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/messaging_hosted_number_orders',
    tags=[
        'hosted_number_management',
        'messaging_management',
        'number_order_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_messaging_hosted_number_order(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List messaging hosted number orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/messaging_hosted_number_orders',
    tags=['hosted_number_management', 'messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_messaging_hosted_number_order(
    body: CreateMessagingHostedNumberOrderRequest = None,
):
    """
    Create a messaging hosted number order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/messaging_hosted_number_orders/{id}',
    tags=['hosted_number_management', 'messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_messaging_hosted_number_order(id: str):
    """
    Retrieve a messaging hosted number order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/messaging_hosted_number_orders/{id}/actions/file_upload',
    tags=['hosted_number_management', 'document_management', 'messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def upload_file_messaging_hosted_number_order(id: str, file: UploadFile = ...):
    """
    Upload file required for a messaging hosted number order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/messaging_hosted_numbers/{id}',
    tags=[
        'hosted_number_management',
        'phone_number_management',
        'messaging_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_messaging_hosted_number(id: str):
    """
    Delete a messaging hosted number
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/messaging_profile_metrics',
    tags=['messaging_management', 'messaging_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_messaging_profile_metrics(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    id: Optional[UUID] = None,
    time_frame: Optional[TimeFrame] = '24h',
):
    """
    List messaging profile metrics
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/messaging_profiles',
    tags=['messaging_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_messaging_profiles(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List messaging profiles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/messaging_profiles',
    tags=['messaging_profile_management', 'messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_messaging_profile(body: CreateMessagingProfileRequest):
    """
    Create a messaging profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/messaging_profiles/{id}',
    tags=['messaging_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_messaging_profile(id: UUID):
    """
    Delete a messaging profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/messaging_profiles/{id}',
    tags=['messaging_profile_management', 'messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_messaging_profile(id: UUID):
    """
    Retrieve a messaging profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/messaging_profiles/{id}',
    tags=['messaging_profile_management', 'messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_messaging_profile(id: UUID, body: UpdateMessagingProfileRequest = ...):
    """
    Update a messaging profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/messaging_profiles/{id}/metrics',
    tags=['messaging_profile_management', 'messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_messaging_profile_detailed_metrics(
    id: UUID, time_frame: Optional[TimeFrame] = '24h'
):
    """
    Retrieve messaging profile metrics
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/messaging_profiles/{id}/phone_numbers',
    tags=['phone_number_management', 'messaging_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_messaging_profile_phone_numbers(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    id: UUID = ...,
):
    """
    List phone numbers associated with a messaging profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/messaging_profiles/{id}/short_codes',
    tags=['messaging_profile_management', 'short_code_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_messaging_profile_short_codes(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    id: UUID = ...,
):
    """
    List short codes associated with a messaging profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/messaging_url_domains',
    tags=['messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_messaging_url_domains(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List messaging URL domains
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/mobile_operator_networks',
    description=""" Telnyx has a set of GSM mobile operators partners that are available through our mobile network roaming. This resource is entirely managed by Telnyx and may change over time. That means that this resource won't allow any write operations for it. Still, it's available so it can be used as a support resource that can be related to other resources or become a configuration option. """,
    tags=['mobile_network_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def mobile_operator_networks_get(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_name__starts_with_: Optional[str] = Query(
        None, alias='filter[name][starts_with]'
    ),
    filter_name__contains_: Optional[str] = Query(None, alias='filter[name][contains]'),
    filter_name__ends_with_: Optional[str] = Query(
        None, alias='filter[name][ends_with]'
    ),
    filter_country_code_: Optional[str] = Query(None, alias='filter[country_code]'),
    filter_mcc_: Optional[str] = Query(None, alias='filter[mcc]'),
    filter_mnc_: Optional[str] = Query(None, alias='filter[mnc]'),
    filter_tadig_: Optional[str] = Query(None, alias='filter[tadig]'),
):
    """
    List mobile operator networks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/notification_channels',
    description=""" List notification channels. """,
    tags=['notification_channel_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_notification_channels(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_channel_type_id__eq_: Optional[FilterChannelTypeIdEq] = Query(
        None, alias='filter[channel_type_id][eq]'
    ),
):
    """
    List notification channels
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/notification_channels',
    description=""" Create a notification channel. """,
    tags=['notification_channel_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_notification_channels(body: NotificationChannel = None):
    """
    Create a notification channel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/notification_channels/{id}',
    description=""" Delete a notification channel. """,
    tags=['notification_channel_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_notification_channel(id: UUID):
    """
    Delete a notification channel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/notification_channels/{id}',
    description=""" Retrieve a notification channel. """,
    tags=['notification_channel_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_notification_channel(id: UUID):
    """
    Retrieve a notification channel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/notification_channels/{id}',
    description=""" Update a notification channel. """,
    tags=['notification_channel_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_notification_channel(id: UUID, body: NotificationChannel = ...):
    """
    Update a notification channel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/notification_event_conditions',
    description=""" Returns a list of your notifications events conditions. """,
    tags=['notification_event_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def find_notifications_events_conditions(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_associated_record_type__eq_: Optional[FilterAssociatedRecordTypeEq] = Query(
        None, alias='filter[associated_record_type][eq]'
    ),
):
    """
    List all Notifications Events Conditions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/notification_events',
    description=""" Returns a list of your notifications events. """,
    tags=['notification_event_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def find_notifications_events(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List all Notifications Events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/notification_profiles',
    description=""" Returns a list of your notifications profiles. """,
    tags=['notification_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def find_notifications_profiles(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List all Notifications Profiles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/notification_profiles',
    description=""" Create a notification profile. """,
    tags=['notification_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_notification_profile(body: NotificationProfile = None):
    """
    Create a notification profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/notification_profiles/{id}',
    description=""" Delete a notification profile. """,
    tags=['notification_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_notification_profile(id: UUID):
    """
    Delete a notification profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/notification_profiles/{id}',
    description=""" Retrieve a notification profile. """,
    tags=['notification_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_notification_profile(id: UUID):
    """
    Retrieve a notification profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/notification_profiles/{id}',
    description=""" Update a notification profile. """,
    tags=['notification_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_notification_profile(id: UUID, body: NotificationProfile = ...):
    """
    Update a notification profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/notification_settings',
    description=""" List notification settings. """,
    tags=[
        'notification_setting_management',
        'notification_profile_management',
        'notification_channel_management',
        'notification_event_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_notification_settings(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_notification_profile_id__eq_: Optional[str] = Query(
        None, alias='filter[notification_profile_id][eq]'
    ),
    filter_notification_channel__eq_: Optional[str] = Query(
        None, alias='filter[notification_channel][eq]'
    ),
    filter_notification_event_condition_id__eq_: Optional[str] = Query(
        None, alias='filter[notification_event_condition_id][eq]'
    ),
    filter_associated_record_type__eq_: Optional[FilterAssociatedRecordTypeEq] = Query(
        None, alias='filter[associated_record_type][eq]'
    ),
    filter_status__eq_: Optional[FilterStatusEq] = Query(
        None, alias='filter[status][eq]'
    ),
):
    """
    List notification settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/notification_settings',
    description=""" Add a notification setting. """,
    tags=['notification_setting_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_notification_setting(body: NotificationSetting = None):
    """
    Add a Notification Setting
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/notification_settings/{id}',
    description=""" Delete a notification setting. """,
    tags=['notification_setting_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_notification_setting(id: UUID):
    """
    Delete a notification setting
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/notification_settings/{id}',
    description=""" Retrieve a notification setting. """,
    tags=['notification_setting_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_notification_setting(id: UUID):
    """
    Retrieve a notification setting
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/number_block_orders',
    description=""" Get a paginated list of number block orders. """,
    tags=['number_block_order_management', 'phone_number_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_number_block_orders(
    filter_status_: Optional[str] = Query(None, alias='filter[status]'),
    filter_created_at__gt_: Optional[str] = Query(None, alias='filter[created_at][gt]'),
    filter_created_at__lt_: Optional[str] = Query(None, alias='filter[created_at][lt]'),
    filter_phone_numbers_starting_number_: Optional[str] = Query(
        None, alias='filter[phone_numbers.starting_number]'
    ),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List number block orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/number_block_orders',
    description=""" Creates a phone number block order. """,
    tags=['number_block_order_management', 'number_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_number_block_order(body: CreateNumberBlockOrderRequest):
    """
    Create a number block order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/number_block_orders/{number_block_order_id}',
    description=""" Get an existing phone number block order. """,
    tags=['number_block_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_number_block_order(number_block_order_id: str):
    """
    Retrieve a number block order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/number_lookup/{phone_number}',
    description=""" Returns information about the provided phone number. """,
    tags=['number_lookup_management', 'phone_number_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def number_lookup(phone_number: str, type: Optional[Type18] = None):
    """
    Lookup phone number data
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/number_order_documents',
    description=""" Gets a paginated list of number order documents. """,
    tags=['number_order_document_management', 'number_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_number_order_documents(
    filter_requirement_id_: Optional[str] = Query(None, alias='filter[requirement_id]'),
    filter_created_at__gt_: Optional[str] = Query(None, alias='filter[created_at][gt]'),
    filter_created_at__lt_: Optional[str] = Query(None, alias='filter[created_at][lt]'),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List number order documents
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/number_order_documents',
    description=""" Upload a phone number order document. """,
    tags=['number_order_document_management', 'number_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_number_order_document(body: CreateNumberOrderDocumentRequest):
    """
    Create a number order document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/number_order_documents/{number_order_document_id}',
    description=""" Gets a single number order document. """,
    tags=[
        'number_order_document_management',
        'number_order_management',
        'document_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_number_order_document(number_order_document_id: str):
    """
    Retrieve a number order document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/number_order_documents/{number_order_document_id}',
    description=""" Updates a number order document. """,
    tags=['number_order_management', 'number_order_document_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_number_order_document(
    number_order_document_id: str, body: UpdateNumberOrderDocumentRequest = ...
):
    """
    Update a number order document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/number_order_phone_numbers',
    description=""" Get a list of phone numbers associated to orders. """,
    tags=['phone_number_management', 'number_lookup_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_number_order_phone_numbers():
    """
    Retrieve a list of phone numbers associated to orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/number_order_phone_numbers/{number_order_phone_number_id}',
    description=""" Get an existing number order phone number. """,
    tags=['phone_number_management', 'number_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_number_order_phone_number(number_order_phone_number_id: str):
    """
    Retrieve a number order phone number.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/number_order_phone_numbers/{number_order_phone_number_id}',
    description=""" Updates a number order phone number. """,
    tags=['phone_number_management', 'number_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_number_order_phone_number(
    number_order_phone_number_id: str, body: UpdateNumberOrderPhoneNumberRequest = ...
):
    """
    Update a number order phone number.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/number_orders',
    description=""" Get a paginated list of number orders. """,
    tags=['number_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_number_orders(
    filter_status_: Optional[str] = Query(None, alias='filter[status]'),
    filter_created_at__gt_: Optional[str] = Query(None, alias='filter[created_at][gt]'),
    filter_created_at__lt_: Optional[str] = Query(None, alias='filter[created_at][lt]'),
    filter_phone_numbers_count_: Optional[str] = Query(
        None, alias='filter[phone_numbers_count]'
    ),
    filter_customer_reference_: Optional[str] = Query(
        None, alias='filter[customer_reference]'
    ),
    filter_requirements_met_: Optional[bool] = Query(
        None, alias='filter[requirements_met]'
    ),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List number orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/number_orders',
    description=""" Creates a phone number order. """,
    tags=['number_order_management', 'phone_number_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_number_order(body: CreateNumberOrderRequest):
    """
    Create a number order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/number_orders/{number_order_id}',
    description=""" Get an existing phone number order. """,
    tags=['number_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_number_order(number_order_id: str):
    """
    Retrieve a number order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/number_orders/{number_order_id}',
    description=""" Updates a phone number order. """,
    tags=['number_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_number_order(number_order_id: str, body: UpdateNumberOrderRequest = ...):
    """
    Update a number order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/number_reservations',
    description=""" Gets a paginated list of phone number reservations. """,
    tags=['number_reservation_management', 'phone_number_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_number_reservations(
    filter_status_: Optional[str] = Query(None, alias='filter[status]'),
    filter_created_at__gt_: Optional[str] = Query(None, alias='filter[created_at][gt]'),
    filter_created_at__lt_: Optional[str] = Query(None, alias='filter[created_at][lt]'),
    filter_phone_numbers_phone_number_: Optional[str] = Query(
        None, alias='filter[phone_numbers.phone_number]'
    ),
    filter_customer_reference_: Optional[str] = Query(
        None, alias='filter[customer_reference]'
    ),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List number reservations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/number_reservations',
    description=""" Creates a Phone Number Reservation for multiple numbers. """,
    tags=['number_reservation_management', 'phone_number_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_number_reservation(body: CreateNumberReservationRequest):
    """
    Create a number reservation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/number_reservations/{number_reservation_id}',
    description=""" Gets a single phone number reservation. """,
    tags=['number_reservation_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_number_reservation(number_reservation_id: str):
    """
    Retrieve a number reservation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/number_reservations/{number_reservation_id}/actions/extend',
    description=""" Extends reservation expiry time on all phone numbers. """,
    tags=['number_reservation_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def extend_number_reservation_expiry_time(number_reservation_id: str):
    """
    Extend a number reservation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ota_updates',
    tags=['ota_update_management', 'sim_card_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def o_t_a_updates_list(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_status_: Optional[FilterStatus2] = Query(None, alias='filter[status]'),
    filter_sim_card_id_: Optional[str] = Query(None, alias='filter[sim_card_id]'),
    filter_type_: Optional[FilterType3] = Query(None, alias='filter[type]'),
):
    """
    List OTA updates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ota_updates/{id}',
    description=""" This API returns the details of an Over the Air (OTA) update. """,
    tags=['ota_update_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def o_t_a_update_g_e_t(id: UUID):
    """
    Get OTA update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/outbound_voice_profiles',
    description=""" Get all outbound voice profiles belonging to the user that match the given filters. """,
    tags=['outbound_voice_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_outbound_voice_profiles(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_name__contains_: Optional[str] = Query(None, alias='filter[name][contains]'),
    sort: Optional[Sort20] = '-created_at',
):
    """
    Get all outbound voice profiles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/outbound_voice_profiles',
    description=""" Create an outbound voice profile. """,
    tags=['outbound_voice_profile_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_outbound_voice_profile(body: CreateOutboundVoiceProfileRequest):
    """
    Create an outbound voice profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/outbound_voice_profiles/{id}',
    description=""" Deletes an existing outbound voice profile. """,
    tags=['outbound_voice_profile_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_outbound_voice_profile(id: str):
    """
    Delete an outbound voice profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/outbound_voice_profiles/{id}',
    description=""" Retrieves the details of an existing outbound voice profile. """,
    tags=['outbound_voice_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_outbound_voice_profile(id: str):
    """
    Retrieve an outbound voice profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/outbound_voice_profiles/{id}',
    description=""" Updates an existing outbound voice profile. """,
    tags=['outbound_voice_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_outbound_voice_profile(
    id: str, body: UpdateOutboundVoiceProfileRequest = ...
):
    """
    Updates an existing outbound voice profile.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_number_blocks/jobs',
    tags=[
        'phone_number_management',
        'phone_number_jobs_management',
        'phone_number_block_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_phone_number_blocks_jobs(
    filter_type_: Optional[FilterType5] = Query(None, alias='filter[type]'),
    filter_status_: Optional[FilterStatus4] = Query(None, alias='filter[status]'),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    sort: Optional[Sort22] = None,
):
    """
    Lists the phone number blocks jobs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/phone_number_blocks/jobs/delete_phone_number_block',
    description=""" Creates a new background job to delete all the phone numbers associated with the given block. We will only consider the phone number block as deleted after all phone numbers associated with it are removed, so multiple executions of this job may be necessary in case some of the phone numbers present errors during the deletion process. """,
    tags=['phone_number_management', 'phone_number_block_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_phone_number_blocks_job_delete_phone_number_block(
    body: PhoneNumberBlocksJobDeletePhoneNumberBlockRequest,
):
    """
    Deletes all numbers associated with a phone number block
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_number_blocks/jobs/{id}',
    tags=[
        'phone_number_management',
        'phone_number_block_management',
        'phone_number_jobs_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_phone_number_blocks_job(id: str):
    """
    Retrieves a phone number blocks job
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_numbers',
    tags=[
        'phone_number_management',
        'number_lookup_management',
        'phone_number_jobs_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_phone_numbers(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_tag_: Optional[str] = Query(None, alias='filter[tag]'),
    filter_phone_number_: Optional[str] = Query(None, alias='filter[phone_number]'),
    filter_status_: Optional[FilterStatus6] = Query(None, alias='filter[status]'),
    filter_voice_connection_name__contains_: Optional[str] = Query(
        None, alias='filter[voice.connection_name][contains]'
    ),
    filter_voice_connection_name__starts_with_: Optional[str] = Query(
        None, alias='filter[voice.connection_name][starts_with]'
    ),
    filter_voice_connection_name__ends_with_: Optional[str] = Query(
        None, alias='filter[voice.connection_name][ends_with]'
    ),
    filter_voice_connection_name__eq_: Optional[str] = Query(
        None, alias='filter[voice.connection_name][eq]'
    ),
    filter_usage_payment_method_: Optional[FilterUsagePaymentMethod] = Query(
        None, alias='filter[usage_payment_method]'
    ),
    filter_billing_group_id_: Optional[str] = Query(
        None, alias='filter[billing_group_id]'
    ),
    filter_emergency_address_id_: Optional[str] = Query(
        None, alias='filter[emergency_address_id]'
    ),
    filter_customer_reference_: Optional[str] = Query(
        None, alias='filter[customer_reference]'
    ),
    sort: Optional[Sort24] = None,
):
    """
    List phone numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_numbers/csv_downloads',
    tags=['csv_download_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_csv_downloads(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List CSV downloads
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/phone_numbers/csv_downloads',
    tags=['csv_download_management', 'document_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_csv_download():
    """
    Create a CSV download
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_numbers/csv_downloads/{id}',
    tags=['csv_download_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_csv_download(id: str):
    """
    Retrieve a CSV download
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_numbers/inbound_channels',
    description=""" Returns the inbound channels for your account. Inbound channels allows you to use Channel Billing for calls to your Telnyx phone numbers. Please check the Telnyx Support Articles section for full information and examples of how to utilize Channel Billing. """,
    tags=['notification_channel_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_outbound_channels():
    """
    Retrieve your inbound channels
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/phone_numbers/inbound_channels',
    description=""" Update the inbound channels for the account """,
    tags=['phone_number_management', 'outbound_channel_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_outbound_channels(body: PhoneNumbersInboundChannelsPatchRequest):
    """
    Update inbound channels
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_numbers/jobs',
    tags=['phone_number_management', 'phone_number_jobs_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_phone_numbers_jobs(
    filter_type_: Optional[FilterType7] = Query(None, alias='filter[type]'),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    sort: Optional[Sort26] = None,
):
    """
    Lists the phone numbers jobs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/phone_numbers/jobs/delete_phone_numbers',
    description=""" Creates a new background job to delete a batch of numbers. At most one thousand numbers can be updated per API call. """,
    tags=['phone_number_management', 'phone_number_jobs_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_phone_numbers_job_delete_phone_numbers(
    body: PhoneNumbersJobDeletePhoneNumbersRequest,
):
    """
    Delete a batch of numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/phone_numbers/jobs/update_emergency_settings',
    description=""" Creates a background job to update the emergency settings of a collection of phone numbers. At most one thousand numbers can be updated per API call. """,
    tags=['phone_number_management', 'phone_number_jobs_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_phone_numbers_job_update_emergency_settings(
    body: PhoneNumbersJobUpdateEmergencySettingsRequest,
):
    """
    Update the emergency settings from a batch of numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/phone_numbers/jobs/update_phone_numbers',
    description=""" Creates a new background job to update a batch of numbers. At most one thousand numbers can be updated per API call. At least one of the updateable fields must be submitted. """,
    tags=['phone_number_management', 'phone_number_jobs_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_phone_numbers_job_update_phone_number(
    body: PhoneNumbersJobUpdatePhoneNumbersRequest,
):
    """
    Update a batch of numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_numbers/jobs/{id}',
    tags=[
        'phone_number_management',
        'phone_number_jobs_management',
        'number_lookup_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_phone_numbers_job(id: str):
    """
    Retrieve a phone numbers job
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_numbers/messaging',
    tags=[
        'phone_number_management',
        'messaging_profile_management',
        'messaging_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_phone_numbers_with_messaging_settings(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List phone numbers with messaging settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_numbers/voice',
    tags=[
        'phone_number_management',
        'number_lookup_management',
        'phone_number_jobs_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_phone_numbers_with_voice_settings(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_phone_number_: Optional[str] = Query(None, alias='filter[phone_number]'),
    filter_connection_name__contains_: Optional[str] = Query(
        None, alias='filter[connection_name][contains]'
    ),
    filter_customer_reference_: Optional[str] = Query(
        None, alias='filter[customer_reference]'
    ),
    filter_usage_payment_method_: Optional[FilterUsagePaymentMethod] = Query(
        None, alias='filter[usage_payment_method]'
    ),
    sort: Optional[Sort28] = None,
):
    """
    List phone numbers with voice settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/phone_numbers/{id}',
    tags=['telephony_credential_management', 'phone_number_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_phone_number(id: str):
    """
    Delete a phone number
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_numbers/{id}',
    tags=['phone_number_management', 'number_lookup_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_phone_number(id: str):
    """
    Retrieve a phone number
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/phone_numbers/{id}',
    tags=['phone_number_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_phone_number(id: str, body: UpdatePhoneNumberRequest = ...):
    """
    Update a phone number
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/phone_numbers/{id}/actions/enable_emergency',
    tags=['phone_number_management', 'phone_number_jobs_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def enable_emergency_phone_number(
    id: str, body: PhoneNumberEnableEmergencyRequest = ...
):
    """
    Enable emergency for a phone number
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_numbers/{id}/messaging',
    tags=['phone_number_management', 'messaging_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_phone_number_with_messaging_settings(id: str):
    """
    Retrieve a phone number with messaging settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/phone_numbers/{id}/messaging',
    tags=['phone_number_management', 'messaging_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_phone_number_with_messaging_settings(
    id: str, body: UpdatePhoneNumberMessagingSettingsRequest = ...
):
    """
    Update a phone number with messaging settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/phone_numbers/{id}/voice',
    tags=['phone_number_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_phone_number_with_voice_settings(id: str):
    """
    Retrieve a phone number with voice settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/phone_numbers/{id}/voice',
    tags=['phone_number_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_phone_number_with_voice_settings(
    id: str, body: UpdatePhoneNumberVoiceSettingsRequest = ...
):
    """
    Update a phone number with voice settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portability_checks',
    description=""" Runs a portability check, returning the results immediately. """,
    tags=['number_portability_management', 'porting_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_portability_check(body: PortabilityChecksPostRequest):
    """
    Run a portability check
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/porting_orders',
    description=""" Returns a list of your porting order. """,
    tags=['porting_order_management', 'number_portability_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_porting_orders(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    include_phone_numbers: Optional[bool] = True,
    filter_status_: Optional[PortingOrderStatus] = Query(None, alias='filter[status]'),
    filter_customer_reference_: Optional[str] = Query(
        None, alias='filter[customer_reference]'
    ),
    filter_phone_numbers__country_code_: Optional[str] = Query(
        None, alias='filter[phone_numbers][country_code]'
    ),
    filter_phone_numbers__carrier_name_: Optional[str] = Query(
        None, alias='filter[phone_numbers][carrier_name]'
    ),
    filter_misc__type_: Optional[PortingOrderType] = Query(
        None, alias='filter[misc][type]'
    ),
    filter_end_user__admin__entity_name_: Optional[str] = Query(
        None, alias='filter[end_user][admin][entity_name]'
    ),
    filter_end_user__admin__auth_person_name_: Optional[str] = Query(
        None, alias='filter[end_user][admin][auth_person_name]'
    ),
    filter_activation_settings__fast_port_eligible_: Optional[bool] = Query(
        None, alias='filter[activation_settings][fast_port_eligible]'
    ),
    filter_activation_settings__foc_datetime_requested__gt_: Optional[str] = Query(
        None, alias='filter[activation_settings][foc_datetime_requested][gt]'
    ),
    filter_activation_settings__foc_datetime_requested__lt_: Optional[str] = Query(
        None, alias='filter[activation_settings][foc_datetime_requested][lt]'
    ),
    sort: Optional[Sort30] = None,
):
    """
    List all porting orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/porting_orders',
    description=""" Creates a new porting order object. """,
    tags=['porting_order_management', 'number_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_porting_order(body: CreatePortingOrder):
    """
    Create a porting order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/porting_orders/exception_types',
    description=""" Returns a list of all possible exception types for a porting order. """,
    tags=['request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_porting_orders_exception_types():
    """
    List all exception types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/porting_orders/{id}',
    description=""" Request the cancellation of a porting order. """,
    tags=['request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_porting_order(id: UUID):
    """
    Request cancellation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/porting_orders/{id}',
    description=""" Retrieves the details of an existing porting order. """,
    tags=['porting_order_management', 'number_portability_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_porting_order(id: UUID, include_phone_numbers: Optional[bool] = True):
    """
    Retrieve a porting order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/porting_orders/{id}',
    description=""" Edits the details of an existing porting order.

Any or all of a porting order’s attributes may be included in the resource object included in a PATCH request.

If a request does not include all of the attributes for a resource, the system will interpret the missing attributes as if they were included with their current values. To explicitly set something to null, it must be included in the request with a null value. """,
    tags=['porting_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_porting_order(id: UUID, body: UpdatePortingOrder = ...):
    """
    Edit a porting order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/porting_orders/{id}/actions/activate',
    description=""" Activate every numbers of a porting order asynchronously. """,
    tags=['porting_order_management', 'number_portability_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def activate_porting_order(id: UUID):
    """
    Activates every number on a porting order.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/porting_orders/{id}/actions/cancel',
    description=""" Cancel this porting order """,
    tags=['porting_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def cancel_porting_order(id: UUID):
    """
    Cancel this porting order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/porting_orders/{id}/actions/confirm',
    description=""" Confirm your porting order. """,
    tags=['porting_order_management', 'number_portability_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def confirm_porting_order(id: UUID):
    """
    Confirms the porting order is ready to be actioned.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/porting_orders/{id}/activation_jobs',
    description=""" Returns a list of your porting activation jobs. """,
    tags=['porting_order_management', 'number_portability_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_porting_orders_activation_jobs(
    id: UUID,
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List all porting activation jobs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/porting_orders/{id}/activation_jobs/{activationJobId}',
    description=""" Returns a porting activation job. """,
    tags=['porting_order_management', 'number_portability_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_porting_orders_activation_job(
    id: UUID, activation_job_id: UUID = Path(..., alias='activationJobId')
):
    """
    Retrieve a porting activation job
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/porting_orders/{id}/comments',
    description=""" Returns a list of all comments of a porting order. """,
    tags=['comment_management', 'porting_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_porting_orders_comments(
    id: UUID,
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List all comments of a porting order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/porting_orders/{id}/comments',
    description=""" Creates a new comment for a porting order. """,
    tags=['comment_management', 'porting_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_porting_order_comment(id: UUID, body: CreatePortingOrderComment = ...):
    """
    Create a comment for a porting order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/porting_orders/{id}/loa_template',
    description=""" Download a porting order loa template """,
    tags=['document_management', 'porting_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_porting_order_l_o_a_template(id: UUID):
    """
    Download a porting order loa template
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/porting_phone_numbers',
    description=""" Returns a list of your porting phone numbers. """,
    tags=[
        'phone_number_management',
        'porting_order_management',
        'number_portability_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_porting_phone_numbers(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_porting_order_id_: Optional[UUID] = Query(
        None, alias='filter[porting_order_id]'
    ),
    filter_phone_number_: Optional[str] = Query(None, alias='filter[phone_number]'),
    filter_activation_status_: Optional[ActivationStatus] = Query(
        None, alias='filter[activation_status]'
    ),
    filter_portability_status_: Optional[PortabilityStatus] = Query(
        None, alias='filter[portability_status]'
    ),
):
    """
    List all porting phone numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/portouts',
    description=""" Returns the portout requests according to filters """,
    tags=['portout_request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_portout_request(
    filter_carrier_name_: Optional[str] = Query(None, alias='filter[carrier_name]'),
    filter_spid_: Optional[str] = Query(None, alias='filter[spid]'),
    filter_status_: Optional[FilterStatus8] = Query(None, alias='filter[status]'),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    Retrieve a list of portout requests
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/portouts/{id}',
    description=""" Returns the portout request based on the ID provided """,
    tags=['portout_request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def find_portout_request(id: UUID):
    """
    Retrieve a portout request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/portouts/{id}/comments',
    description=""" Returns a list of comments for a portout request. """,
    tags=['portout_request_management', 'comment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def find_portout_comments(id: UUID):
    """
    List all comments for a portout request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portouts/{id}/comments',
    description=""" Creates a comment on a portout request. """,
    tags=['portout_request_management', 'comment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_port_request_comment(id: UUID, body: PortoutsIdCommentsPostRequest = ...):
    """
    Create a comment on a portout request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/portouts/{id}/{status}',
    description=""" Authorize or reject portout request """,
    tags=['sim_card_management', 'network_preferences_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_portout_request(id: UUID, status: Status55 = ...):
    """
    Update Status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/private_wireless_gateways',
    description=""" Get all Private Wireless Gateways belonging to the user. """,
    tags=['private_wireless_gateway_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_private_wireless_gateways(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_name_: Optional[str] = Query(None, alias='filter[name]'),
    filter_ip_range_: Optional[str] = Query(None, alias='filter[ip_range]'),
    filter_region_code_: Optional[str] = Query(None, alias='filter[region_code]'),
    filter_created_at_: Optional[str] = Query(None, alias='filter[created_at]'),
    filter_updated_at_: Optional[str] = Query(None, alias='filter[updated_at]'),
):
    """
    Get all Private Wireless Gateways
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/private_wireless_gateways',
    description=""" Asynchronously create a Private Wireless Gateway for SIM cards for a previously created network. """,
    tags=['private_wireless_gateway_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_private_wireless_gateway(body: PrivateWirelessGatewaysPostRequest):
    """
    Create a Private Wireless Gateway
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/private_wireless_gateways/{id}',
    description=""" Deletes the Private Wireless Gateway. """,
    tags=['private_wireless_gateway_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_private_wireless_gateway(id: UUID):
    """
    Delete a Private Wireless Gateway
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/private_wireless_gateways/{id}',
    description=""" Retrieve information about a Private Wireless Gateway. """,
    tags=['private_wireless_gateway_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_private_wireless_gateway(id: UUID):
    """
    Get a Private Wireless Gateway
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/queues/{queue_name}',
    description=""" Retrieve an existing call queue """,
    tags=['call_queue_management', 'call_queue_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_call_queue(queue_name: str):
    """
    Retrieve a call queue
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/queues/{queue_name}/calls',
    description=""" Retrieve the list of calls in an existing queue """,
    tags=['call_queue_management', 'call_queue_operations', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_queue_calls(
    queue_name: str,
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    Retrieve calls from a queue
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/queues/{queue_name}/calls/{call_control_id}',
    description=""" Retrieve an existing call from an existing queue """,
    tags=['call_queue_management', 'call_management', 'call_queue_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_call_from_queue(queue_name: str, call_control_id: str = ...):
    """
    Retrieve a call from a queue
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/recordings',
    description=""" Lists recordings for the authenticated user """,
    tags=['recording_management', 'call_recording_management', 'conference_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_recordings(
    filter_conference_id_: Optional[str] = Query(None, alias='filter[conference_id]'),
    filter_created_at__gte_: Optional[str] = Query(
        None, alias='filter[created_at][gte]'
    ),
    filter_created_at__lte_: Optional[str] = Query(
        None, alias='filter[created_at][lte]'
    ),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List recordings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/recordings/{id}',
    description=""" Retrieve a recording from the authenticated user's recordings """,
    tags=['recording_management', 'call_recording_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_recording(id: str):
    """
    Retrieve a recording
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reports/batch_mdr_reports',
    description=""" Fetch all previous requests for messaging detail reports. Messaging detail reports are reports for pulling all messaging records.  """,
    tags=['request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_cdr_requests(
    page_number_: Optional[int] = Query(1, alias='page[number]'),
    page_size_: Optional[int] = Query(20, alias='page[size]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reports/batch_mdr_reports',
    description=""" Submit a request for new messaging detail report. Messaging detail report pulls all raw messaging data according to defined filters. """,
    tags=['mdr_request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def submit_mdr_request(body: MdrPostDetailReportRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/reports/batch_mdr_reports/{id}',
    description=""" Delete generated messaging detail report by id """,
    tags=['request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_mdr_request(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reports/batch_mdr_reports/{id}',
    description=""" Fetch single messaging detail report by id. """,
    tags=['request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_mdr_request(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reports/cdr_usage_reports/sync',
    description=""" Generate and fetch voice usage report synchronously. This endpoint will both generate and fetch the voice report over a specified time period. No polling is necessary but the response may take up to a couple of minutes.  """,
    tags=['record_search_management', 'usage_report_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_usage_report_sync(
    start_date: Optional[datetime_aliased] = None,
    end_date: Optional[datetime_aliased] = None,
    aggregation_type: AggregationType3 = ...,
    product_breakdown: ProductBreakdown = ...,
    connections: Optional[Connections1] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reports/mdr_usage_reports',
    description=""" Fetch all messaging usage reports. Usage reports are aggregated messaging data for specified time period and breakdown """,
    tags=['request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_usage_reports(
    page_number_: Optional[int] = Query(1, alias='page[number]'),
    page_size_: Optional[int] = Query(20, alias='page[size]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reports/mdr_usage_reports',
    description=""" Submit request for new new messaging usage report. This endpoint will pull and aggregate messaging data in specified time period.  """,
    tags=['request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def submit_usage_report():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reports/mdr_usage_reports/sync',
    description=""" Generate and fetch messaging usage report synchronously. This endpoint will both generate and fetch the messaging report over a specified time period. No polling is necessary but the response may take up to a couple of minutes.  """,
    tags=[
        'record_search_management',
        'recording_management',
        'usage_report_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_usage_report_sync_1(
    start_date: Optional[datetime_aliased] = None,
    end_date: Optional[datetime_aliased] = None,
    aggregation_type: AggregationType5 = ...,
    profiles: Optional[Profiles] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/reports/mdr_usage_reports/{id}',
    description=""" Delete messaging usage report by id """,
    tags=['authentication_provider_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_usage_report(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reports/mdr_usage_reports/{id}',
    description=""" Fetch a single messaging usage report by id """,
    tags=['user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_usage_report(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reports/mdrs',
    description=""" Fetch all Mdr records  """,
    tags=['call_event_management', 'call_management', 'call_queue_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_reports_mdrs(
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    id: Optional[str] = None,
    direction: Optional[Direction13] = None,
    profile: Optional[str] = None,
    cld: Optional[str] = None,
    cli: Optional[str] = None,
    status: Optional[Status56] = None,
    message_type: Optional[MessageType3] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reports/wdrs',
    description=""" Fetch all Wdr records  """,
    tags=[
        'sim_card_management',
        'sim_card_group_management',
        'phone_number_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_paginated_wdrs(
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    id: Optional[str] = None,
    mcc: Optional[str] = None,
    mnc: Optional[str] = None,
    imsi: Optional[str] = None,
    sim_group_name: Optional[str] = None,
    sim_group_id: Optional[str] = None,
    sim_card_id: Optional[str] = None,
    phone_number: Optional[str] = None,
    page_number_: Optional[int] = Query(1, alias='page[number]'),
    page_size_: Optional[int] = Query(20, alias='page[size]'),
    sort: Optional[Sort32] = 'created_at',
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/requirement_types',
    description=""" List all requirement types ordered by created_at descending """,
    tags=['requirement_documentation_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def doc_reqs_list_requirement_types(
    filter_name__contains_: Optional[str] = Query(None, alias='filter[name][contains]'),
    sort__: Optional[Sort33] = Query(None, alias='sort[]'),
):
    """
    List all requirement types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/requirement_types/{id}',
    description=""" Retrieve a requirement type by id """,
    tags=['requirement_documentation_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def doc_reqs_retrieve_requirement_type(id: UUID):
    """
    Retrieve a requirement types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/requirements',
    description=""" List all requirements with filtering, sorting, and pagination """,
    tags=[
        'phone_number_management',
        'call_event_management',
        'record_search_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_requirements(
    filter_country_code_: Optional[str] = Query(None, alias='filter[country_code]'),
    filter_phone_number_type_: Optional[FilterPhoneNumberType2] = Query(
        None, alias='filter[phone_number_type]'
    ),
    filter_action_: Optional[FilterAction] = Query(None, alias='filter[action]'),
    sort__: Optional[Sort35] = Query(None, alias='sort[]'),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List all requirements
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/requirements/{id}',
    description=""" Retrieve a document requirement record """,
    tags=['document_management', 'requirement_documentation_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def doc_reqs_retrieve_document_requirements(id: UUID):
    """
    Retrieve a document requirement
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/room_participants',
    tags=['room_management', 'session_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_room_participants(
    filter_date_joined_at__eq_: Optional[date] = Query(
        None, alias='filter[date_joined_at][eq]'
    ),
    filter_date_joined_at__gte_: Optional[date] = Query(
        None, alias='filter[date_joined_at][gte]'
    ),
    filter_date_joined_at__lte_: Optional[date] = Query(
        None, alias='filter[date_joined_at][lte]'
    ),
    filter_date_updated_at__eq_: Optional[date] = Query(
        None, alias='filter[date_updated_at][eq]'
    ),
    filter_date_updated_at__gte_: Optional[date] = Query(
        None, alias='filter[date_updated_at][gte]'
    ),
    filter_date_updated_at__lte_: Optional[date] = Query(
        None, alias='filter[date_updated_at][lte]'
    ),
    filter_date_left_at__eq_: Optional[date] = Query(
        None, alias='filter[date_left_at][eq]'
    ),
    filter_date_left_at__gte_: Optional[date] = Query(
        None, alias='filter[date_left_at][gte]'
    ),
    filter_date_left_at__lte_: Optional[date] = Query(
        None, alias='filter[date_left_at][lte]'
    ),
    filter_context_: Optional[str] = Query(None, alias='filter[context]'),
    filter_session_id_: Optional[str] = Query(None, alias='filter[session_id]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
):
    """
    View a list of room participants.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/room_participants/{room_participant_id}',
    tags=['room_management', 'session_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def view_room_participant(room_participant_id: UUID):
    """
    View a room participant.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/room_sessions',
    tags=['room_management', 'session_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_room_sessions(
    filter_date_created_at__eq_: Optional[date] = Query(
        None, alias='filter[date_created_at][eq]'
    ),
    filter_date_created_at__gte_: Optional[date] = Query(
        None, alias='filter[date_created_at][gte]'
    ),
    filter_date_created_at__lte_: Optional[date] = Query(
        None, alias='filter[date_created_at][lte]'
    ),
    filter_date_updated_at__eq_: Optional[date] = Query(
        None, alias='filter[date_updated_at][eq]'
    ),
    filter_date_updated_at__gte_: Optional[date] = Query(
        None, alias='filter[date_updated_at][gte]'
    ),
    filter_date_updated_at__lte_: Optional[date] = Query(
        None, alias='filter[date_updated_at][lte]'
    ),
    filter_date_ended_at__eq_: Optional[date] = Query(
        None, alias='filter[date_ended_at][eq]'
    ),
    filter_date_ended_at__gte_: Optional[date] = Query(
        None, alias='filter[date_ended_at][gte]'
    ),
    filter_date_ended_at__lte_: Optional[date] = Query(
        None, alias='filter[date_ended_at][lte]'
    ),
    filter_room_id_: Optional[str] = Query(None, alias='filter[room_id]'),
    filter_active_: Optional[bool] = Query(None, alias='filter[active]'),
    include_participants: Optional[bool] = None,
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
):
    """
    View a list of room sessions.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/room_sessions/{room_session_id}',
    tags=['room_management', 'session_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def view_room_session(
    room_session_id: UUID, include_participants: Optional[bool] = None
):
    """
    View a room session.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/room_sessions/{room_session_id}/participants',
    tags=['room_management', 'session_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def nested_list_room_participants(
    room_session_id: UUID,
    filter_date_joined_at__eq_: Optional[date] = Query(
        None, alias='filter[date_joined_at][eq]'
    ),
    filter_date_joined_at__gte_: Optional[date] = Query(
        None, alias='filter[date_joined_at][gte]'
    ),
    filter_date_joined_at__lte_: Optional[date] = Query(
        None, alias='filter[date_joined_at][lte]'
    ),
    filter_date_updated_at__eq_: Optional[date] = Query(
        None, alias='filter[date_updated_at][eq]'
    ),
    filter_date_updated_at__gte_: Optional[date] = Query(
        None, alias='filter[date_updated_at][gte]'
    ),
    filter_date_updated_at__lte_: Optional[date] = Query(
        None, alias='filter[date_updated_at][lte]'
    ),
    filter_date_left_at__eq_: Optional[date] = Query(
        None, alias='filter[date_left_at][eq]'
    ),
    filter_date_left_at__gte_: Optional[date] = Query(
        None, alias='filter[date_left_at][gte]'
    ),
    filter_date_left_at__lte_: Optional[date] = Query(
        None, alias='filter[date_left_at][lte]'
    ),
    filter_context_: Optional[str] = Query(None, alias='filter[context]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
):
    """
    View a list of room participants.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/rooms',
    tags=['room_management', 'session_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_rooms(
    filter_date_created_at__eq_: Optional[date] = Query(
        None, alias='filter[date_created_at][eq]'
    ),
    filter_date_created_at__gte_: Optional[date] = Query(
        None, alias='filter[date_created_at][gte]'
    ),
    filter_date_created_at__lte_: Optional[date] = Query(
        None, alias='filter[date_created_at][lte]'
    ),
    filter_date_updated_at__eq_: Optional[date] = Query(
        None, alias='filter[date_updated_at][eq]'
    ),
    filter_date_updated_at__gte_: Optional[date] = Query(
        None, alias='filter[date_updated_at][gte]'
    ),
    filter_date_updated_at__lte_: Optional[date] = Query(
        None, alias='filter[date_updated_at][lte]'
    ),
    filter_unique_name_: Optional[str] = Query(None, alias='filter[unique_name]'),
    include_sessions: Optional[bool] = None,
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
):
    """
    View a list of rooms.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/rooms',
    description=""" Synchronously create a Room. """,
    tags=['room_management', 'session_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_room(body: CreateRoomRequest):
    """
    Create a room.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/rooms/{room_id}',
    description=""" Synchronously delete a Room. Participants from that room will be kicked out, they won't be able to join that room anymore, and you won't be charged anymore for that room. """,
    tags=['room_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_room(room_id: UUID):
    """
    Delete a room.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/rooms/{room_id}',
    tags=['room_management', 'session_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def view_room(room_id: UUID, include_sessions: Optional[bool] = None):
    """
    View a room.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/rooms/{room_id}/actions/generate_join_client_token',
    description=""" Synchronously create an Client Token to join a Room. Client Token is necessary to join a Telnyx Room. Client Token will expire after `token_ttl_secs`, a Refresh Token is also provided to refresh a Client Token, the Refresh Token expires after `refresh_token_ttl_secs`. """,
    tags=['room_management', 'session_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_room_client_token(room_id: UUID, body: CreateRoomClientTokenRequest = ...):
    """
    Create Client Token to join a room.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/rooms/{room_id}/actions/refresh_client_token',
    description=""" Synchronously refresh an Client Token to join a Room. Client Token is necessary to join a Telnyx Room. Client Token will expire after `token_ttl_secs`. """,
    tags=[
        'room_management',
        'session_management',
        'authentication_provider_management',
    ],
)
def refresh_room_client_token(room_id: UUID, body: RefreshRoomClientTokenRequest = ...):
    """
    Refresh Client Token to join a room.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/rooms/{room_id}/sessions',
    tags=['room_management', 'session_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def nested_list_room_sessions(
    room_id: UUID,
    filter_date_created_at__eq_: Optional[date] = Query(
        None, alias='filter[date_created_at][eq]'
    ),
    filter_date_created_at__gte_: Optional[date] = Query(
        None, alias='filter[date_created_at][gte]'
    ),
    filter_date_created_at__lte_: Optional[date] = Query(
        None, alias='filter[date_created_at][lte]'
    ),
    filter_date_updated_at__eq_: Optional[date] = Query(
        None, alias='filter[date_updated_at][eq]'
    ),
    filter_date_updated_at__gte_: Optional[date] = Query(
        None, alias='filter[date_updated_at][gte]'
    ),
    filter_date_updated_at__lte_: Optional[date] = Query(
        None, alias='filter[date_updated_at][lte]'
    ),
    filter_date_ended_at__eq_: Optional[date] = Query(
        None, alias='filter[date_ended_at][eq]'
    ),
    filter_date_ended_at__gte_: Optional[date] = Query(
        None, alias='filter[date_ended_at][gte]'
    ),
    filter_date_ended_at__lte_: Optional[date] = Query(
        None, alias='filter[date_ended_at][lte]'
    ),
    filter_active_: Optional[bool] = Query(None, alias='filter[active]'),
    include_participants: Optional[bool] = None,
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
):
    """
    View a list of room sessions.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/short_codes',
    tags=['short_code_management', 'messaging_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_short_codes(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_messaging_profile_id_: Optional[str] = Query(
        None, alias='filter[messaging_profile_id]'
    ),
):
    """
    List short codes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/short_codes/{id}',
    tags=['short_code_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_short_code(id: UUID):
    """
    Retrieve a short code
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/short_codes/{id}',
    description=""" Update the settings for a specific short code. To unbind a short code from a profile, set the `messaging_profile_id` to `null` or an empty string. """,
    tags=['short_code_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_short_code(id: UUID, body: UpdateShortCodeRequest = ...):
    """
    Update short code
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim_card_group_actions',
    description=""" This API allows listing a paginated collection a SIM card group actions. It allows to explore a collection of existing asynchronous operation using specific filters. """,
    tags=['sim_card_management', 'sim_card_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_group_actions_get(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_sim_card_group_id_: Optional[UUID] = Query(
        None, alias='filter[sim_card_group_id]'
    ),
    filter_status_: Optional[FilterStatus10] = Query(None, alias='filter[status]'),
    filter_type_: Optional[FilterType9] = Query(None, alias='filter[type]'),
):
    """
    List SIM card group actions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim_card_group_actions/{id}',
    description=""" This API allows fetching detailed information about a SIM card group action resource to make follow-ups in an existing asynchronous operation. """,
    tags=['sim_card_management', 'sim_card_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_group_action_get(id: UUID):
    """
    Get SIM card group action details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim_card_groups',
    description=""" Get all SIM card groups belonging to the user that match the given filters. """,
    tags=['sim_card_management', 'sim_card_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_groups_get_all(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_name_: Optional[UUID] = Query(None, alias='filter[name]'),
):
    """
    Get all SIM card groups
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sim_card_groups',
    description=""" Creates a new SIM card group object """,
    tags=['sim_card_management', 'sim_card_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_groups_post(body: SIMCardGroupCreate):
    """
    Create a SIM card group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/sim_card_groups/{id}',
    description=""" Permanently deletes a SIM card group """,
    tags=['sim_card_management', 'sim_card_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_group_delete(id: UUID):
    """
    Delete a SIM card group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim_card_groups/{id}',
    description=""" Returns the details regarding a specific SIM card group """,
    tags=['sim_card_group_management', 'sim_card_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_groups_get(id: UUID):
    """
    Get SIM card group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/sim_card_groups/{id}',
    description=""" Updates a SIM card group """,
    tags=['sim_card_management', 'sim_card_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_group_update(id: UUID, body: SIMCardGroupPatch = ...):
    """
    Update a SIM card group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sim_card_groups/{id}/actions/remove_private_wireless_gateway',
    description=""" This action will asynchronously remove an existing Private Wireless Gateway definition from a SIM card group. Completing this operation defines that all SIM cards in the SIM card group will get their traffic handled by Telnyx's default mobile network configuration. """,
    tags=['private_wireless_gateway_management', 'sim_card_group_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def remove_s_i_m_card_group_private_wireless_gateway(id: UUID):
    """
    Request Private Wireless Gateway removal from SIM card group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sim_card_groups/{id}/actions/set_private_wireless_gateway',
    description=""" This action will asynchronously assign a provisioned Private Wireless Gateway to the SIM card group. Completing this operation defines that all SIM cards in the SIM card group will get their traffic controlled by the associated Private Wireless Gateway. This operation will also imply that new SIM cards assigned to a group will inherit its network definitions. If it's moved to a different group that doesn't have a Private Wireless Gateway, it'll use Telnyx's default mobile network configuration. """,
    tags=[
        'sim_card_management',
        'private_wireless_gateway_management',
        'sim_card_group_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def set_s_i_m_card_group_private_wireless_gateway(
    id: UUID, body: SimCardGroupsIdActionsSetPrivateWirelessGatewayPostRequest = ...
):
    """
    Request Private Wireless Gateway assignment for SIM card group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sim_card_order_preview',
    description=""" Preview SIM card order purchases. """,
    tags=['sim_card_order_management', 'sim_card_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_orders_preview(body: SimCardOrderPreviewPostRequest = None):
    """
    Preview SIM card orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim_card_orders',
    description=""" Get all SIM card orders according to filters. """,
    tags=['sim_card_management', 'sim_card_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_orders_get(
    filter_created_at_: Optional[str] = Query(None, alias='filter[created_at]'),
    filter_updated_at_: Optional[str] = Query(None, alias='filter[updated_at]'),
    filter_quantity_: Optional[int] = Query(None, alias='filter[quantity]'),
    filter_cost_amount_: Optional[str] = Query(None, alias='filter[cost.amount]'),
    filter_cost_currency_: Optional[str] = Query(None, alias='filter[cost.currency]'),
    filter_address_id_: Optional[str] = Query(None, alias='filter[address.id]'),
    filter_address_street_address_: Optional[str] = Query(
        None, alias='filter[address.street_address]'
    ),
    filter_address_extended_address_: Optional[str] = Query(
        None, alias='filter[address.extended_address]'
    ),
    filter_address_locality_: Optional[str] = Query(
        None, alias='filter[address.locality]'
    ),
    filter_address_administrative_area_: Optional[str] = Query(
        None, alias='filter[address.administrative_area]'
    ),
    filter_address_country_code_: Optional[str] = Query(
        None, alias='filter[address.country_code]'
    ),
    filter_address_postal_code_: Optional[str] = Query(
        None, alias='filter[address.postal_code]'
    ),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    Get all SIM card orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sim_card_orders',
    description=""" Creates a new order for SIM cards. """,
    tags=['sim_card_order_management', 'sim_card_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_orders_post(body: SimCardOrderCreate):
    """
    Create a SIM card order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim_card_orders/{id}',
    description=""" Get a single SIM card order by its ID. """,
    tags=['sim_card_order_management', 'sim_card_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_order_get(id: UUID):
    """
    Get a single SIM card order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim_cards',
    description=""" Get all SIM cards belonging to the user that match the given filters. """,
    tags=[
        'sim_card_management',
        'sim_card_group_management',
        'network_preferences_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_cards_get(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    include_sim_card_group: Optional[bool] = False,
    filter_sim_card_group_id_: Optional[UUID] = Query(
        None, alias='filter[sim_card_group_id]'
    ),
    filter_tags_: Optional[FilterTags] = Query(None, alias='filter[tags]'),
    filter_iccid_: Optional[str] = Query(None, alias='filter[iccid]'),
):
    """
    Get all SIM cards
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sim_cards/actions/validate_registration_codes',
    description=""" It validates whether SIM card registration codes are valid or not. """,
    tags=[
        'telephony_credential_management',
        'sim_card_management',
        'verification_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_validate_registration_codes(
    body: SimCardsActionsValidateRegistrationCodesPostRequest,
):
    """
    Validate SIM cards registration codes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/sim_cards/{id}',
    description=""" The SIM card will be decommissioned, removed from your account and you will stop being charged.<br />The SIM card won't be able to connect to the network after the deletion is completed, thus making it impossible to consume data.<br/>
Transitioning to the disabled state may take a period of time.</br>
Until the transition is completed, the SIM card status will be disabling <code>disabling</code>.<br />In order to re-enable the SIM card, you will need to re-register it. """,
    tags=['sim_card_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_delete(id: UUID):
    """
    Deletes a SIM card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim_cards/{id}',
    description=""" Returns the details regarding a specific SIM card. """,
    tags=['sim_card_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_get(id: UUID, include_sim_card_group: Optional[bool] = False):
    """
    Get SIM card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/sim_cards/{id}',
    description=""" Updates a SIM card's group and tags """,
    tags=['sim_card_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_update(id: UUID, body: SIMCard = ...):
    """
    Update a SIM card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sim_cards/{id}/actions/disable',
    description=""" The SIM card won't be able to connect to the network after the disabling is completed, thus making it impossible to consume data.<br/>
Transitioning to the disabled state may take a period of time.</br>
Until the transition is completed, the SIM card status will be <code>disabling</code>.
 """,
    tags=['sim_card_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_disable(id: UUID):
    """
    Request a SIM card disable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sim_cards/{id}/actions/enable',
    description=""" The SIM card will be able to connect to the network once the enabling is complete, thus making it possible to consume data.<br/>
To enable a SIM card, it must be associated with SIM card group.<br/>
Transitioning to the enabled state may take a period of time. Until the transition is completed, the SIM card status will be <code>enabling</code>.
 """,
    tags=['sim_card_management', 'telephony_credential_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_enable(id: UUID):
    """
    Request a SIM card enable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sim_cards/{id}/actions/set_standby',
    description=""" The SIM card will be able to connect to the network once the process to set it to standby has been completed, thus making it possible to consume data.<br/>
To set a SIM card to standby, it must be associated with SIM card group.<br/>
Transitioning to the standby state may take a period of time. Until the transition is completed, the SIM card status will be <code>setting_standby</code>.
 """,
    tags=['sim_card_management', 'network_preferences_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sim_card_set_standby(id: UUID):
    """
    Request setting a SIM card to standby
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/sim_cards/{sim_card_id}/network_preferences',
    description=""" This API asynchronously removes the custom-defined network preferences settings. After this operation is done the Telnyx default settings, the same applied for an unaltered SIM card, will be in place.
 """,
    tags=['network_preferences_management', 'sim_card_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def s_i_m_card_network_preferences_delete(sim_card_id: UUID):
    """
    DELETE network preferences
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim_cards/{sim_card_id}/network_preferences',
    description=""" It returns the network preferences currently applied in the SIM card.
 """,
    tags=['network_preferences_management', 'sim_card_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def s_i_m_card_network_preferences_get(
    sim_card_id: UUID, include_ota_updates: Optional[bool] = False
):
    """
    Get network preferences
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/sim_cards/{sim_card_id}/network_preferences',
    description=""" This API allows setting or updating a SIM card network preference. <br/><br/>
Every SIM card has default network preferences defined on Telnyx. These preferences will determine how a SIMCard will connect to the network by considering a list of preferable operators.<br/><br/>
There can be multiple scenarios where an operator can be preferred over another, for example, when a specific mobile operator can provide better network latency or better pricing.
 """,
    tags=['network_preferences_management', 'sim_card_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def s_i_m_card_network_preferences_put(
    sim_card_id: UUID, body: SimCardsSimCardIdNetworkPreferencesPutRequest = None
):
    """
    Set network preferences
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/sim_cards/{sim_card_id}/public_ip',
    description=""" This API asynchronously removes an existing public IP from a SIM card.
 """,
    tags=['sim_card_management', 'public_ip_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def s_i_m_card_public_i_p_delete(sim_card_id: UUID):
    """
    Delete SIM card public IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim_cards/{sim_card_id}/public_ip',
    description=""" It returns the public IP requested for a SIM card.
 """,
    tags=['sim_card_management', 'public_ip_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def s_i_m_card_public_i_p_get(sim_card_id: UUID):
    """
    Get SIM card public IP definition
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sim_cards/{sim_card_id}/public_ip',
    description=""" This API will asynchronously map a random public IP to a SIM card, making it reachable on the public internet. <br/><br/>
 The request will return the resource as "provisioning" right away, and it'll eventually get "provisioned", meaning it completed the setup. <br/><br/>
 Setting up a public IP will generate charges, and we won't be able to provide the IP if the account doesn't have a balance. In that case, this operation will succeed, but its status will change to failed eventually, and the resource will be updated with the associated status. The IP resource will need to be deleted and re-created with our DELETE and POST APIs in this scenario. """,
    tags=['sim_card_management', 'public_ip_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def s_i_m_card_public_i_p_post(sim_card_id: UUID):
    """
    Set SIM card public IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim_cards/{sim_card_id}/wireless_connectivity_logs',
    description=""" This API allows listing a paginated collection of Wireless Connectivity Logs associated with a SIM Card, for troubleshooting purposes. """,
    tags=['sim_card_management', 'wdr_report_management', 'wdr_report_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def wireless_connectivity_logs_get(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    sim_card_id: UUID = ...,
):
    """
    List wireless connectivity logs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sub_number_orders',
    description=""" Get a paginated list of sub number orders. """,
    tags=['sub_number_order_management', 'number_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_sub_number_orders(
    filter_user_id_: Optional[UUID] = Query(None, alias='filter[user_id]'),
    filter_order_request_id_: Optional[UUID] = Query(
        None, alias='filter[order_request_id]'
    ),
    filter_country_code_: Optional[str] = Query(None, alias='filter[country_code]'),
    filter_phone_number_type_: Optional[str] = Query(
        None, alias='filter[phone_number_type]'
    ),
    filter_phone_numbers_count_: Optional[int] = Query(
        None, alias='filter[phone_numbers_count]'
    ),
):
    """
    List sub number orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sub_number_orders/{sub_number_order_id}',
    description=""" Get an existing sub number order. """,
    tags=['sub_number_order_management', 'number_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_sub_number_order(
    sub_number_order_id: str,
    filter_include_phone_numbers_: Optional[bool] = Query(
        False, alias='filter[include_phone_numbers]'
    ),
):
    """
    Retrieve a sub number order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/sub_number_orders/{sub_number_order_id}',
    description=""" Updates a sub number order. """,
    tags=['sub_number_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_sub_number_order(
    sub_number_order_id: str, body: UpdateSubNumberOrderRequest = ...
):
    """
    Update a sub number order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/telephony_credentials',
    description=""" List all On-demand Credentials. """,
    tags=['telephony_credential_management', 'connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def find_telephony_credentials(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_tag_: Optional[str] = Query(None, alias='filter[tag]'),
    filter_name_: Optional[str] = Query(None, alias='filter[name]'),
    filter_status_: Optional[str] = Query(None, alias='filter[status]'),
    filter_resource_id_: Optional[str] = Query(None, alias='filter[resource_id]'),
    filter_sip_username_: Optional[str] = Query(None, alias='filter[sip_username]'),
):
    """
    List all credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/telephony_credentials',
    description=""" Create a credential. """,
    tags=['telephony_credential_management', 'connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_telephony_credential(body: TelephonyCredentialCreateRequest):
    """
    Create a credential
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/telephony_credentials/tags',
    description=""" Returns a list of tags used on Credentials """,
    tags=['request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_tags(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List all tags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/telephony_credentials/{id}',
    description=""" Delete an existing credential. """,
    tags=['telephony_credential_management', 'authentication_provider_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_telephony_credential(id: str):
    """
    Delete a credential
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/telephony_credentials/{id}',
    description=""" Get the details of an existing On-demand Credential. """,
    tags=[
        'telephony_credential_management',
        'authentication_provider_management',
        'connection_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_telephony_credential(id: str):
    """
    Get a credential
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/telephony_credentials/{id}',
    description=""" Update an existing credential. """,
    tags=['telephony_credential_management', 'connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_telephony_credential(id: str, body: TelephonyCredentialUpdateRequest = ...):
    """
    Update a credential
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/telephony_credentials/{id}/actions/{action}',
    description=""" Perform activate or deactivate action on provided Credential. Activate action will change the status to active, making it possible to connect calls with the credential. Deactivate action will change the status to inactive, making it impossible to connect calls with the credential. """,
    tags=[
        'telephony_credential_management',
        'authentication_provider_management',
        'connection_management',
        'managed_account_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def telephony_credential_action(id: str, action: Action1 = ...):
    """
    Perform activate or deactivate action on provided Credential
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/telephony_credentials/{id}/token',
    description=""" Create an Access Token (JWT) for the credential. """,
    tags=['authentication_provider_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_telephony_credential_token(id: str):
    """
    Create an Access Token.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/texml_applications',
    description=""" Returns a list of your TeXML Applications. """,
    tags=['texml_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def find_texml_applications(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
    filter_friendly_name__contains_: Optional[str] = Query(
        'null', alias='filter[friendly_name][contains]'
    ),
    filter_outbound_voice_profile_id_: Optional[str] = Query(
        None, alias='filter[outbound_voice_profile_id]'
    ),
    sort: Optional[Sort37] = 'created_at',
):
    """
    List all TeXML Applications
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/texml_applications',
    description=""" Creates a TeXML Application. """,
    tags=['texml_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_texml_application(body: CreateTexmlApplicationRequest):
    """
    Creates a TeXML Application
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/texml_applications/{id}',
    description=""" Deletes a TeXML Application. """,
    tags=['texml_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_texml_application(id: str):
    """
    Deletes a TeXML Application
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/texml_applications/{id}',
    description=""" Retrieves the details of an existing TeXML Application. """,
    tags=['texml_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_texml_application(id: str):
    """
    Retrieve a TeXML Application
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/texml_applications/{id}',
    description=""" Updates settings of an existing TeXML Application. """,
    tags=['texml_application_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_texml_application(id: str, body: UpdateTexmlApplicationRequest = ...):
    """
    Update a TeXML Application
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/verifications/by_phone_number/{phone_number}',
    tags=['phone_number_management', 'verification_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_verifications(phone_number: str):
    """
    List verifications by phone number
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/verifications/by_phone_number/{phone_number}/actions/verify',
    tags=['verification_management', 'phone_number_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def verify_verification_code(
    phone_number: str, body: VerifyVerificationCodeRequest = ...
):
    """
    Submit a verification code
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/verifications/call',
    tags=['verification_management', 'call_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_verification_call(body: CreateVerificationRequestCall):
    """
    Trigger a Call verification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/verifications/flashcall',
    tags=['verification_management', 'phone_number_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_verification_flashcall(body: CreateVerificationRequestFlashcall):
    """
    Trigger a Flash call verification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/verifications/psd2',
    tags=['verification_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_verification_p_s_d2(body: CreateVerificationRequestPSD2):
    """
    Trigger a PSD2 verification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/verifications/sms',
    tags=['verification_management', 'messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_verification_s_m_s(body: CreateVerificationRequestSMS):
    """
    Trigger a SMS verification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/verifications/whatsapp',
    tags=['verification_management', 'whatsapp_message_management', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_verification_whatsapp(body: CreateVerificationRequestWhatsapp):
    """
    Trigger a Whatsapp verification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/verifications/{verification_id}',
    tags=['verification_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_verification(verification_id: UUID):
    """
    Retrieve a verification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/verify_profiles',
    description=""" Gets a paginated list of Verify profiles. """,
    tags=['verification_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_verify_profiles(
    filter_name_: Optional[str] = Query(None, alias='filter[name]'),
    page_size_: Optional[int] = Query(25, alias='page[size]'),
    page_number_: Optional[int] = Query(1, alias='page[number]'),
):
    """
    List all Verify profiles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/verify_profiles',
    description=""" Creates a new Verify profile to associate verifications with. """,
    tags=['verification_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_verify_profile(body: VerifyProfilesPostRequest):
    """
    Create a Verify profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/verify_profiles/{verify_profile_id}',
    tags=['verification_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_verify_profile(verify_profile_id: UUID):
    """
    Delete a Verify profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/verify_profiles/{verify_profile_id}',
    description=""" Gets a single Verify profile. """,
    tags=['verification_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_verify_profile(verify_profile_id: UUID):
    """
    Retrieve a Verify profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/verify_profiles/{verify_profile_id}',
    tags=['verification_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_verify_profile(
    verify_profile_id: UUID, body: VerifyProfilesVerifyProfileIdPatchRequest = ...
):
    """
    Update a Verify profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/webhook_deliveries',
    description=""" Lists webhook_deliveries for the authenticated user """,
    tags=['webhook_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_webhook_deliveries(
    filter_status__eq_: Optional[FilterStatusEq2] = Query(
        None, alias='filter[status][eq]'
    ),
    filter_webhook__contains_: Optional[str] = Query(
        None, alias='filter[webhook][contains]'
    ),
    filter_attempts__contains_: Optional[str] = Query(
        None, alias='filter[attempts][contains]'
    ),
    filter_started_at__gte_: Optional[str] = Query(
        None, alias='filter[started_at][gte]'
    ),
    filter_started_at__lte_: Optional[str] = Query(
        None, alias='filter[started_at][lte]'
    ),
    filter_finished_at__gte_: Optional[str] = Query(
        None, alias='filter[finished_at][gte]'
    ),
    filter_finished_at__lte_: Optional[str] = Query(
        None, alias='filter[finished_at][lte]'
    ),
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    List webhook deliveries
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/webhook_deliveries/{id}',
    description=""" Provides webhook_delivery debug data, such as timestamps, delivery status and attempts. """,
    tags=['webhook_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_webhook_delivery(id: UUID):
    """
    Find webhook_delivery details by ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/whatsapp_contacts',
    description=""" Verify that a phone number belongs to a valid WhatsApp account. You must ensure that the status is valid before you can message a user, and you'll get their WhatsApp ID to use for messaging. """,
    tags=['phone_number_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def check_contact(body: CheckContactRequestBody):
    """
    Check Contact
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/whatsapp_detail_record_reports',
    description=""" Fetch all previous requests for WhatsApp detail reports. WhatsApp detail reports are reports for pulling all WhatsApp records.  """,
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_requests(
    page_number_: Optional[int] = Query(1, alias='page[number]'),
    page_size_: Optional[int] = Query(20, alias='page[size]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/whatsapp_detail_record_reports',
    description=""" Submit a request for new WhatsApp detail report. WhatsApp detail report pulls all raw WhatsApp data according to defined filters. """,
    tags=['whatsapp_message_management', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def submit_request(body: WhatsAppReportsReq):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/whatsapp_detail_record_reports/{id}',
    description=""" Delete generated WhatsApp detail report by id """,
    tags=['authentication_provider_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_request(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/whatsapp_detail_record_reports/{id}',
    description=""" Fetch single whatsapp detail report by id. """,
    tags=['request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_request(id: UUID):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/whatsapp_media',
    description=""" Upload media. Accepted media types include image/jpeg, image/png, video/mp4, video/3gpp, audio/aac, audio/ogg. """,
    tags=['media_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def upload_media(file: UploadFile):
    """
    Upload Media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/whatsapp_media/{whatsapp_user_id}/{media_id}',
    description=""" Delete uploaded media. """,
    tags=['media_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_whatsapp_media__whatsapp_user_id__media_id(
    whatsapp_user_id: str, media_id: str = ...
):
    """
    Delete Media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/whatsapp_media/{whatsapp_user_id}/{media_id}',
    description=""" Retrieve uploaded media. Media is typically available for 30 days after uploading. """,
    tags=['media_management', 'whatsapp_message_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_whatsapp_media__whatsapp_user_id__media_id(
    whatsapp_user_id: str, media_id: str = ...
):
    """
    Download Media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/whatsapp_messages',
    description=""" Send text messages, media/documents, and message templates to your customers. """,
    tags=['whatsapp_message_management', 'messaging_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def send_message(body: CreateWhatsAppMessageRequest):
    """
    Send Message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/whatsapp_messages/{message_id}',
    description=""" Mark a message as read. """,
    tags=[
        'comment_management',
        'messaging_management',
        'notification_event_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def mark_message_as_read(message_id: str, body: MarkMessageAsReadRequestBody = ...):
    """
    Mark Message As Read
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/whatsapp_usage_aggregations',
    description=""" Generate and fetch WhatsApp usage aggregations synchronously. This endpoint will both generate and fetch the WhatsApp aggregations over a specified time period.  """,
    tags=['request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_usage_aggregations_sync(
    start_date: Optional[datetime_aliased] = None,
    end_date: Optional[datetime_aliased] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/whatsapp_users/{whatsapp_user_id}',
    description=""" Retrieve WhatsApp user information. """,
    tags=['user_management', 'whatsapp_message_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_user(whatsapp_user_id: str):
    """
    Get User
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/whatsapp_users/{whatsapp_user_id}',
    description=""" Update webhook URL used for a given WhatsApp user. """,
    tags=['user_management', 'whatsapp_message_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_whats_app_webhook(whatsapp_user_id: str, body: UpdateUserRequest = ...):
    """
    Update WhatsApp User
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless/detail_records_reports',
    description=""" Returns the WDR Reports that match the given parameters. """,
    tags=['wdr_report_management', 'wdr_report_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_wdr_reports(
    page_number_: Optional[conint(ge=1)] = Query(1, alias='page[number]'),
    page_size_: Optional[conint(ge=1, le=250)] = Query(20, alias='page[size]'),
):
    """
    Get all Wireless Detail Records (WDRs) Reports
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wireless/detail_records_reports',
    description=""" Asynchronously create a report containing Wireless Detail Records (WDRs) for the SIM cards that consumed wireless data in the given time period.
 """,
    tags=['wdr_report_management', 'wdr_report_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_wdr_report(body: WdrReportRequest):
    """
    Create a Wireless Detail Records (WDRs) Report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/wireless/detail_records_reports/{id}',
    description=""" Deletes one specific WDR report """,
    tags=['wdr_report_management', 'wdr_report_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_wdr_report(id: UUID):
    """
    Delete a Wireless Detail Record (WDR) Report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wireless/detail_records_reports/{id}',
    description=""" Returns one specific WDR report """,
    tags=['wdr_report_management', 'wdr_report_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_wdr_report(id: UUID):
    """
    Get a Wireless Detail Record (WDR) Report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
